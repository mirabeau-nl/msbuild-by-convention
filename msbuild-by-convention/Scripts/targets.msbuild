<!-- originally posted at https://github.com/JorritSalverda/msbuild-by-convention/ -->

<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003" ToolsVersion="4.0">

  <Import Project="properties-convention-based.msbuild"/>
  <!-- Only import specific file if it exists -->
  <Import Project="$(CustomBuildScriptsDirectory)properties-repository-specific.msbuild" Condition="exists('$(CustomBuildScriptsDirectory)properties-repository-specific.msbuild')"/>
  
  <!-- beginregion Build targets -->		
  <Target Name="PrepareGlobalProperties">

    <ConvertToAbsolutePath Paths="$(SourceDirectory)">
      <Output TaskParameter="AbsolutePaths" PropertyName="AbsoluteSourceDirectory" />
    </ConvertToAbsolutePath>
    <ConvertToAbsolutePath Paths="$(CloudExtensionsDir)">
      <Output TaskParameter="AbsolutePaths" PropertyName="AbsoluteCloudExtensionsDir" />
    </ConvertToAbsolutePath>
    <ConvertToAbsolutePath Paths="$(ExtensionTasksPath)">
      <Output TaskParameter="AbsolutePaths" PropertyName="AbsoluteExtensionTasksPath" />
    </ConvertToAbsolutePath>
    <ConvertToAbsolutePath Paths="$(SqlServerRedistPath)">
      <Output TaskParameter="AbsolutePaths" PropertyName="AbsoluteSqlServerRedistPath" />
    </ConvertToAbsolutePath>		
    <ConvertToAbsolutePath Paths="$(VSToolsPath)">
      <Output TaskParameter="AbsolutePaths" PropertyName="AbsoluteVSToolsPath" />
    </ConvertToAbsolutePath>		
    <ConvertToAbsolutePath Paths="$(BuildToolsDirectory)">
      <Output TaskParameter="AbsolutePaths" PropertyName="AbsoluteBuildToolsDirectory" />
    </ConvertToAbsolutePath>
    <ConvertToAbsolutePath Paths="$(VisualStudioSqlServerDataToolsDir)">
      <Output TaskParameter="AbsolutePaths" PropertyName="AbsoluteVisualStudioSqlServerDataToolsDir" />
    </ConvertToAbsolutePath>
    <ConvertToAbsolutePath Paths="$(CommonTargetsExtensionFile)">
      <Output TaskParameter="AbsolutePaths" PropertyName="AbsoluteCommonTargetsExtensionFile" />
    </ConvertToAbsolutePath>		

    <PropertyGroup>
      <ReleaseVersionFromFile></ReleaseVersionFromFile>
    </PropertyGroup>

    <ReadLinesFromFile File="$(ReleaseVersionFilePath)" Condition=" Exists('$(ReleaseVersionFilePath)') " >
            <Output TaskParameter="Lines" ItemName="ReleaseVersionFromFile"/>
        </ReadLinesFromFile>

    <PropertyGroup Condition=" '@(ReleaseVersionFromFile)' != '' And '$(BuildNumber)' != '' ">
      <BuildVersion>@(ReleaseVersionFromFile).$(BuildNumber)</BuildVersion>
    </PropertyGroup>

    <PropertyGroup Condition=" '$(BuildVersion)' == '' And '$(BuildNumber)' != '' ">
      <BuildVersion>1.0.0.$(BuildNumber)</BuildVersion>
    </PropertyGroup>

    <PropertyGroup Condition=" '$(BuildVersion)' == '' ">
      <BuildVersion>1.0.0.0</BuildVersion>
    </PropertyGroup>

    <PropertyGroup>
      <BuildParameters>$(BuildParameters);CloudExtensionsDir=$(AbsoluteCloudExtensionsDir);AbsoluteExtensionTasksPath=$(AbsoluteExtensionTasksPath);AbsoluteSourceDirectory=$(AbsoluteSourceDirectory);SqlServerRedistPath=$(AbsoluteSqlServerRedistPath);VSToolsPath=$(AbsoluteVSToolsPath);AbsoluteBuildToolsDirectory=$(AbsoluteBuildToolsDirectory);SqlServerRedistPath=$(AbsoluteSqlServerRedistPath);SsdtTargetsParentPath=$(AbsoluteVisualStudioSqlServerDataToolsDir);CommonTargetsExtensionFile=$(AbsoluteCommonTargetsExtensionFile)</BuildParameters>
      <VersionedFilePostfix>-$(BuildVersion)</VersionedFilePostfix>			
    </PropertyGroup>

    <Message Importance="high" Text="The BuildVersion for this build is: $(BuildVersion)" />

  </Target>	
  <Target Name="InstallBuildDependencies" DependsOnTargets="PrepareGlobalProperties;InstallChocolatey;FetchToolsWithChocolatey;DownloadToolsWithNuget;_PrepareVsTools">	
  </Target>
  <Target Name="InstallDeployDependencies" DependsOnTargets="PrepareGlobalProperties;DownloadToolsWithNuget;_PrepareVsTools">	
  </Target>

  <Target Name="InstallChocolatey" Condition="!Exists($([System.Environment]::ExpandEnvironmentVariables('$(ChocoPath)')))">
    <PropertyGroup>
      <ChocolateyInstallLine>@powershell -NoProfile -ExecutionPolicy unrestricted -Command "iex ((new-object net.webclient).DownloadString('https://chocolatey.org/install.ps1'))" &amp;&amp; SET PATH=%PATH%;%ALLUSERSPROFILE%\chocolatey\bin</ChocolateyInstallLine>
    </PropertyGroup>
	  <Message Text="Installing chocolatey" Importance="Normal" />
    <!--- Install Chocolatey -->
    <Exec Command="$(ChocolateyInstallLine)" />		
	  <Message Text="Chocolatey installed, you may need to close and open the commandprompt." Importance="high" />
  </Target>
  
  <Target Name="FetchToolsWithChocolatey">
    <PropertyGroup>
      <ChocoPackagesInstalledCheckFile>$(BuildToolsDirectory)choco_packages_installed.txt</ChocoPackagesInstalledCheckFile>
    </PropertyGroup>
    
    <ReadLinesFromFile File="$(ChocoPackagesInstalledCheckFile)" Condition=" Exists('$(ChocoPackagesInstalledCheckFile)') " >
            <Output TaskParameter="Lines" ItemName="LastChocoRunBuildVersionFromFile"/>
    </ReadLinesFromFile>
    
    <Message Text="Same version, no need to install chocoo packages" Importance="Normal" Condition=" @(LastChocoRunBuildVersionFromFile) == $(BuildVersion) " />
    <Message Text="Other version, fetching choco packages first" Importance="Normal" Condition=" @(LastChocoRunBuildVersionFromFile) != $(BuildVersion) " />
              
    <MSBuild Projects="$(ScriptsDirectory)install-dependencies-lib.msbuild" Targets="ExecuteCommandAndCheckOuputOnCondition" Condition=" @(LastChocoRunBuildVersionFromFile) != $(BuildVersion) " />    		
    
    <WriteLinesToFile File="$(ChocoPackagesInstalledCheckFile)" Lines="$(BuildVersion)" Overwrite="true" />
  </Target>	
  <Target Name="DownloadToolsWithNuget">
    <Exec Command="$(NuGetPath) install $(BuildToolsDirectory)packages.config -NonInteractive -OutputDirectory $(BuildToolsDirectory) -ConfigFile &quot;$(NuGetConfigPath)&quot;" Condition=" Exists('$(BuildToolsDirectory)/packages.config') " />		
  </Target>
  <Target Name="_PrepareVsTools" DependsOnTargets="DownloadToolsWithNuget">
    <!-- Copy Web publish targets to $(LocalVSToolsPath) else the web project files cannot find the proper include .targets files-->
    <ItemGroup>
      <_WebPublishTasksSourceFiles Include="$(WebPublishingTargetsSourceDirectory)**\*.*"/>
    </ItemGroup>    
    <Copy SourceFiles="@(_WebPublishTasksSourceFiles)" DestinationFolder="$(LocalVSToolsPath)\%(RecursiveDir)"/>
    <Message Text="Current VSToolsPath is: $(VSToolsPath)" Importance="normal"/>
  </Target>  
  
  <Target Name="SplitReleaseConfigurations" DependsOnTargets="DownloadToolsWithNuget" BeforeTargets="CoreRelease;ReleaseAzure">
	<!-- begin fix for removal of quote's by Bamboo -->
	<!-- the property /p:ConfigurationsToRelease="UAT;PROD" can now be passes as /p:ConfigurationsToRelease=UAT%3bPROD -->
	<Message Text="ConfigurationsToRelease Collection contains: %(ConfigurationsToRelease.Identity)"/>
	<ItemGroup>
		<__ConfigurationsToRelease Remove="@(__ConfigurationsToRelease)" />
		<__ConfigurationsToRelease Remove="@(ConfigurationsToRelease)" />
		<__ConfigurationsToRelease Include="@(ConfigurationsToRelease)" />
	</ItemGroup>
	<ItemGroup>
		<ConfigurationsToRelease Remove="@(ConfigurationsToRelease)" />
	</ItemGroup>
      <!-- Convert a seperated list to an ItemGroup -->
	<MSBuild.ExtensionPack.Framework.MsBuildHelper TaskAction="StringToItemCol" ItemString="%(__ConfigurationsToRelease.Identity)" Separator=";" Condition=" '@(__ConfigurationsToRelease)' != '' ">
		<Output TaskParameter="OutputItems" ItemName="ConfigurationsToRelease"/>
	</MSBuild.ExtensionPack.Framework.MsBuildHelper>	
	<Message Text="ConfigurationsToRelease Collection contains: %(ConfigurationsToRelease.Identity)"/>
	<!-- end fix -->  	  
  </Target>
  
  <UsingTask AssemblyFile="$(MSBuildCommunityTasksPath)" TaskName="MSBuild.Community.Tasks.WebDownload" />
  <Target Name="DownloadAndExtractJmeterToBuildTools" DependsOnTargets="DownloadToolsWithNuget">
    <PropertyGroup>
      <JmeterVersion>2.11</JmeterVersion>
      <SourceUrl>http://archive.apache.org/dist/jmeter/binaries/apache-jmeter-$(JmeterVersion).zip</SourceUrl>
      <TargetZipFilename>$(BuildToolsDirectory)jmeter-$(JmeterVersion).zip</TargetZipFilename>
      <TargetUnzipDirectory>$(BuildToolsDirectory)apache-jmeter-$(JmeterVersion)</TargetUnzipDirectory>
    </PropertyGroup>
    <WebDownload FileName="$(TargetZipFilename)" FileUri="$(SourceUrl)" Condition="!Exists('$(TargetUnzipDirectory)') and !Exists('$(TargetZipFilename)') "/>
    <Unzip ZipFileName="$(TargetZipFilename)" TargetDirectory="$(TargetUnzipDirectory)" Condition="!Exists('$(TargetUnzipDirectory)')" />
  </Target>
  <Target Name="UpdatePathAfterToolsInstall" AfterTargets="InstallBuildDependencies">
    <PropertyGroup>
      <PATH>$(Registry:HKEY_CURRENT_USER\Environment@PATH);$(Registry:HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Environment@Path)</PATH>
      <PATH>$(PATH);$(APPDATA)\npm</PATH>
    </PropertyGroup>		
    
    <SetEnvironmentVariable VariableName="PATH" VariableValue="$(PATH)"/>	
    <Message Importance="high" Text="Setting Path to: $(PATH)" />	
  </Target>

  <!-- tasks used for nunit, attrib en other tasks -->
  <!-- Need to be places after some dependencies are obtained from nuget, elsee a file not exist error will occurr -->
  <UsingTask AssemblyFile="$(MSBuildCommunityTasksPath)" TaskName="MSBuild.Community.Tasks.Attrib" />
  <UsingTask AssemblyFile="$(MSBuildCommunityTasksPath)" TaskName="MSBuild.Community.Tasks.FileUpdate" />
  <UsingTask AssemblyFile="$(MSBuildCommunityTasksPath)" TaskName="MSBuild.Community.Tasks.NUnit" />
  <UsingTask AssemblyFile="$(MSBuildCommunityTasksPath)" TaskName="MSBuild.Community.Tasks.Net.HttpRequest" />
  <UsingTask AssemblyFile="$(MSBuildCommunityTasksPath)" TaskName="MSBuild.Community.Tasks.Zip" />
  <UsingTask AssemblyFile="$(MSBuildCommunityTasksPath)" TaskName="MSBuild.Community.Tasks.Unzip" />
  

  <!-- tasks used for minification -->
  <UsingTask AssemblyFile="$(ExtensionTasksPath)" TaskName="MSBuild.ExtensionPack.FileSystem.Folder"/>
  <UsingTask AssemblyFile="$(ExtensionTasksPath)" TaskName="MSBuild.ExtensionPack.Framework.TextString"/>
  <UsingTask AssemblyFile="$(ExtensionTasksPath)" TaskName="MSBuild.ExtensionPack.Framework.MSBuildHelper"/>
  <UsingTask AssemblyFile="$(ExtensionTasksPath)" TaskName="MSBuild.ExtensionPack.CodeQuality.FxCop"/>
  <UsingTask AssemblyFile="$(ExtensionTasksPath)" TaskName="MSBuild.ExtensionPack.Computer.EnvironmentVariable"/>

  <!-- used for minifying javascript and css -->			
  <UsingTask TaskName="CssCompressorTask" AssemblyFile="$(YUICompressorPath)Yahoo.Yui.Compressor.Build.MsBuild.dll" />
  <UsingTask TaskName="JavaScriptCompressorTask" AssemblyFile="$(YUICompressorPath)Yahoo.Yui.Compressor.Build.MsBuild.dll" />	

  <!-- teamcity uses a custom nunit task to be able to import the output -->				
  <UsingTask TaskName="NUnit" AssemblyFile="$(teamcity_dotnet_nunitlauncher_msbuild_task)" Condition=" '$(teamcity_dotnet_nunitlauncher_msbuild_task)' != '' "/>				

  <!-- task for config transforms -->
  <UsingTask TaskName="TransformXml" AssemblyFile="$(WebPublishingPath)" />

  <!-- task for code coverage -->
  <UsingTask AssemblyFile="$(OpenCoverMSBuildTasksPath)OpenCover.MSBuild.dll" TaskName="OpenCover.MSBuild.OpenCover" />

  <!-- tasks used for deploying windowsservice -->
  <UsingTask AssemblyFile="$(ExtensionTasksPath)" TaskName="MSBuild.ExtensionPack.Computer.Network"/>
  <UsingTask AssemblyFile="$(ExtensionTasksPath)" TaskName="MSBuild.ExtensionPack.Computer.WindowsService"/>
  <UsingTask AssemblyFile="$(ExtensionTasksPath)" TaskName="MSBuild.ExtensionPack.FileSystem.RoboCopy"/>
  


  <Target Name="CreateDirectories" DependsOnTargets="DownloadToolsWithNuget">
    <MakeDir Directories="@(DirectoriesToCreate)" />
  </Target>

  <Target Name="Clean" DependsOnTargets="CoreClean;CreateDirectories" />
  <Target Name="CoreClean">
    <MSBuild.ExtensionPack.FileSystem.Folder TaskAction="RemoveContent" Path="%(DirectoriesToCreate.FullPath)" Condition=" Exists('%(DirectoriesToCreate.FullPath)') " />
    <RemoveDir Directories="@(DirectoriesToCreate)" />
  </Target>

  <Target Name="CopyDependencies">
    <ItemGroup>
      <DependenciesToCopy Include="$(DependencyDirectory)**\*.dll" />
      <DependenciesToCopy Include="$(DependencyDirectory)**\*.xml" />
    </ItemGroup>
    <Copy SourceFiles="@(DependenciesToCopy)" DestinationFolder="$(BinDirectory)" Condition=" @(DependenciesToCopy) != '' And $(CopyDependenciesToBinFolder) == 'True' " />
  </Target>

  <Target Name="SetAssemblyFileVersion">
    <!-- set correct file version -->
    <ItemGroup>
      <AssemblyInfoFiles Include="$(CSharpSourceDirectory)**\AssemblyInfo.cs" />
    </ItemGroup>
    <Attrib ReadOnly="false" Files="@(AssemblyInfoFiles)" />
      <FileUpdate Files="@(AssemblyInfoFiles)" Regex="\[\s*assembly\s*:\s*AssemblyVersion\s*\(\s*&quot;[\d\.\*]+&quot;\s*\)\s*\]" ReplacementText="[assembly: AssemblyVersion(&quot;$(BuildVersion)&quot;)]" Condition=" @(AssemblyInfoFiles) != '' " />
      <FileUpdate Files="@(AssemblyInfoFiles)" Regex="\[\s*assembly\s*:\s*AssemblyFileVersion\s*\(\s*&quot;[\d\.\*]+&quot;\s*\)\s*\]" ReplacementText="[assembly: AssemblyFileVersion(&quot;$(BuildVersion)&quot;)]" Condition=" @(AssemblyInfoFiles) != '' " />
  </Target>
   
  <Target Name="ReplaceProjectImportStatements" Condition=" Exists('$(VisualStudioSqlServerDataToolsDir)Microsoft.Data.Tools.Schema.SqlTasks.targets') ">

    <!-- look for sqlproj files and replace the import statement with one pointing to /build/tools/VisualStudio.v11.0/SSDT -->
    <ItemGroup>
      <DbProjectFiles Remove="@(DbProjectFiles)" />
      <DbProjectFiles Include="$(CSharpSourceDirectory)**\*.$(DatabaseProjectConventionName).sqlproj" Condition=" $(ReplaceSsdtImportStatement) == 'True' " />
    </ItemGroup>

    <!-- keep backup of the project file -->
    <Copy SourceFiles="@(DbProjectFiles)" DestinationFiles="%(DbProjectFiles.FullPath).original" /> 

    <Attrib ReadOnly="false" Files="@(DbProjectFiles)" />
      <FileUpdate Files="@(DbProjectFiles)" Regex="\$\(MSBuildExtensionsPath\)\\Microsoft\\VisualStudio\\v\$\(VisualStudioVersion\)\\SSDT\\" ReplacementText="$(AbsoluteVisualStudioSqlServerDataToolsDir)" Condition=" @(DbProjectFiles) != '' " />

  </Target>

  <Target Name="Compile" DependsOnTargets="Clean;CopyDependencies;SetAssemblyFileVersion;ReplaceProjectImportStatements;BeforeCompile;CoreCompile;AfterCompile;SassCompile;RunGruntFiles" />
  <Target Name="BeforeCompile">

    <CallTarget Targets="CheckJavascriptWithJsHint" Condition=" $(CheckJavascriptOnBuild) == 'True' " />

    <!-- solutions that have a dependency order are specified in properties-repository-specific.msbuild; over here we add all solutions so it's not neccessary to list them all in properties-repository-specific.msbuild -->
    <ItemGroup>
      <SolutionsToBuild Include="$(CSharpSourceDirectory)**\*.sln" />
    </ItemGroup>

    <Delete Files="$(BuildVersionFilePath)" Condition=" Exists('$(BuildVersionFilePath)') " />

  </Target>
  <Target Name="CoreCompile" Inputs="%(SolutionsToBuild.RootDir)%(SolutionsToBuild.Directory)" Outputs="NonExistingOutputToTriggerTargetForEverySolution">
    <Error Text="There are no solutions to compile!" Condition=" @(SolutionsToBuild) == '' " />

      <!-- restore nuget packages -->
      <Exec Command="$(NuGetPath) restore %(SolutionsToBuild.FullPath)" />      
      
    <!-- build solution -->
    <MSBuild Projects="%(SolutionsToBuild.FullPath)" Targets="$(CompileTarget)" Properties="$(BuildParameters)" BuildInParallel="true">
      <Output TaskParameter="TargetOutputs" ItemName="BuildOutput" />
    </MSBuild>

    <!-- compile views for all website and webservice projects -->
    <ItemGroup>
      <ProjectsToBuild Include="%(SolutionsToBuild.RootDir)%(SolutionsToBuild.Directory)**\*.$(WebsiteProjectConventionName).csproj" />
      <ProjectsToBuild Include="%(SolutionsToBuild.RootDir)%(SolutionsToBuild.Directory)**\*.$(WebServiceProjectConventionName).csproj" />
    </ItemGroup>

    <!-- remove obj directory from build directory, otherwise aspnetcompiler might fail due to multiple web.configs -->
    <ItemGroup>
      <DirectoriesToRemove Remove="@(DirectoriesToRemove)" />
      <DirectoriesToRemove Include="%(ProjectsToBuild.RelativeDir)obj" />
    </ItemGroup>

    <MSBuild.ExtensionPack.FileSystem.Folder TaskAction="RemoveContent" Path="%(DirectoriesToRemove.FullPath)" Condition=" Exists('%(DirectoriesToRemove.FullPath)') " />
    <RemoveDir Directories="@(DirectoriesToRemove)" />

    <AspNetCompiler VirtualPath="/" PhysicalPath="%(ProjectsToBuild.RelativeDir)" Condition=" Exists('%(ProjectsToBuild.RelativeDir)Web.config') " />

    <!-- copy output assemblies to build/bin directory -->
        <Copy SourceFiles="@(BuildOutput)" DestinationFolder="$(BinDirectory)" Condition = "%(Extension) == '.dll' Or %(Extension) == '.xml'" />
  </Target>	
  <Target Name="AfterCompile">

    <!-- restore db project file -->
    <ItemGroup>
      <_OriginalDbProjectFiles Remove="@(_OriginalDbProjectFiles)" />
      <_OriginalDbProjectFiles Include="$(CSharpSourceDirectory)**\*.$(DatabaseProjectConventionName).sqlproj.original" />

      <OriginalDbProjectFiles Remove="@(OriginalDbProjectFiles)" />
      <OriginalDbProjectFiles Include="%(_OriginalDbProjectFiles.FullPath)">
        <DestinationFile>$([System.String]::Copy('%(_OriginalDbProjectFiles.FullPath)').Replace(".original",""))</DestinationFile>
      </OriginalDbProjectFiles>
    </ItemGroup>

    <Message Text="OriginalDbProjectFiles: @(OriginalDbProjectFiles)" />

    <Copy SourceFiles="@(OriginalDbProjectFiles)" DestinationFiles="%(OriginalDbProjectFiles.DestinationFile)" />
    <Delete Files="@(OriginalDbProjectFiles)" />

    <!-- indicates which version has been built last in order to do a compile check -->
    <WriteLinesToFile File="$(BuildVersionFilePath)" Lines="$(BuildVersion)" Overwrite="true" />

  </Target>	

  <Target Name="CheckJavascriptWithJsHint">

    <ItemGroup>
      <!-- check all javascript files except for the ones where the filename ends in .min.js -->
      <JavaScriptFiles Include="$(SourceDirectory)**\$(JavascriptDirectoryConventionName)\**\*.js" Exclude="$(SourceDirectory)**\$(JavascriptDirectoryConventionName)\**\*.min.js;$(SourceDirectory)**\obj\**\*.js;$(SourceDirectory)**\csx\**\*.js" />
    </ItemGroup>

    <Exec Command="cscript &quot;$(JSHintPath)&quot; %(JavaScriptFiles.RelativeDir)%(JavaScriptFiles.Filename)%(JavaScriptFiles.Extension)" />		

  </Target>	
   
  
  <Target Name="CompileCheck" DependsOnTargets="InstallBuildDependencies;PrepareGlobalProperties">
    
    <PropertyGroup>
      <BuildVersionFromFile></BuildVersionFromFile>
    </PropertyGroup>

    <ReadLinesFromFile File="$(BuildVersionFilePath)" Condition=" Exists('$(BuildVersionFilePath)') " >
            <Output TaskParameter="Lines" ItemName="BuildVersionFromFile"/>
        </ReadLinesFromFile>

    <Message Text="Same version, no need to compile" Importance="High" Condition=" @(BuildVersionFromFile) == $(BuildVersion) " />
    <Message Text="Other version, compile first"     Importance="High" Condition=" @(BuildVersionFromFile) != $(BuildVersion) " />
    
    <CallTarget Targets="Compile"                Condition=" @(BuildVersionFromFile) != $(BuildVersion) " />		
    <CallTarget Targets="SetAssemblyFileVersion" Condition=" @(BuildVersionFromFile) == $(BuildVersion) " />		

  </Target>

  <!-- endregion Build targets -->

  <!-- beginregion Tests targets -->

  <Target Name="RunUnitTests" DependsOnTargets="CompileCheck;CreateDirectories;BeforeRunUnitTests;CoreRunTests" />
  <Target Name="BeforeRunUnitTests">
    <ItemGroup>
      <TestProjects Include="$(CSharpSourceDirectory)**\*.$(UnitTestsProjectConventionName).csproj" />
    </ItemGroup>	
  </Target>

  <Target Name="RunIntegrationTests" DependsOnTargets="CompileCheck;CreateDirectories;BeforeRunIntegrationTests;CoreRunTests" />
  <Target Name="BeforeRunIntegrationTests">
    <ItemGroup>
      <TestProjects Include="$(CSharpSourceDirectory)**\*.$(IntegrationTestsProjectConventionName).csproj" />
    </ItemGroup>	
  </Target>	

  <Target Name="CoreRunTests">		

    <Delete Files="$(TestResultsDirectory)*" />
    <Delete Files="$(CodeCoverageDirectory)*" />

    <ItemGroup>
      <TestAssemblies Remove="@(TestAssemblies)" />
      <TestAssemblies Include="%(TestProjects.RelativeDir)bin\$(Configuration)\%(TestProjects.Filename).dll" />
      <AssembliesToReportCoverage Remove="@(AssembliesToReportCoverage)" />
      <AssembliesToReportCoverage Include="$(CSharpSourceDirectory)**\*.csproj" Exclude="$(CSharpSourceDirectory)**\*.$(UnitTestsProjectConventionName).csproj;$(CSharpSourceDirectory)**\*.$(IntegrationTestsProjectConventionName).csproj" />
    </ItemGroup>		

    <PropertyGroup>
      <OpenCoverFilter>+[@(AssembliesToReportCoverage -> '%(Filename)', ']* +[')]*</OpenCoverFilter>
    </PropertyGroup>		

    <!-- filter out test assemblies if nunit.framework.dll is not referenced -->
    <ItemGroup>
      <NunitTestAssemblies Remove="@(NunitTestAssemblies)" />
      <NunitTestAssemblies Include="%(TestAssemblies.FullPath)" Condition=" Exists('%(TestAssemblies.RelativeDir)nunit.framework.dll') " />
    </ItemGroup>

    <!-- run tests if coverage is disabled -->
    <NUnit Assemblies="@(NunitTestAssemblies)" ToolPath="$(NUnitToolPath)" OutputXmlFile="$(TestResultsDirectory)NUnit.Results.%(NunitTestAssemblies.Filename).xml" DisableShadowCopy="true" Condition=" @(NunitTestAssemblies) != '' And $(IncludeCoverage) == 'False' " ContinueOnError="$(ContinueOnTestError)" />

    <!-- run tests with coverage (https://github.com/sawilde/opencover/wiki/Usage) -->
    <Exec Command="$(OpenCoverPath)OpenCover.Console.exe -register:user -returntargetcode -target:$(NUnitToolPath)nunit-console.exe -targetargs:&quot;@(NunitTestAssemblies -> '%(FullPath)', ' ') /result=$(TestResultsDirectory)NUnit.Results.%(NunitTestAssemblies.Filename).xml /noshadow&quot; -filter:&quot;$(OpenCoverFilter)&quot; -output:$(CodeCoverageDirectory)NUnit.Coverage.%(NunitTestAssemblies.Filename).xml" Condition=" @(NunitTestAssemblies) != '' And $(IncludeCoverage) == 'True' " ContinueOnError="$(ContinueOnTestError)" />



    <!-- filter out test assemblies if Machine.Specifications.dll is not referenced -->
    <ItemGroup>
      <MSpecTestAssemblies Remove="@(MSpecTestAssemblies)" />
      <MSpecTestAssemblies Include="%(TestAssemblies.FullPath)" Condition=" Exists('%(TestAssemblies.RelativeDir)Machine.Specifications.dll') " />
    </ItemGroup>

    <!-- run tests if coverage is disabled -->
    <Exec Command="$(MSpecRunnerPath) --xml $(TestResultsDirectory)MSpecTemp.Results.%(MSpecTestAssemblies.Filename).xml @(MSpecTestAssemblies -> '%(Identity)', ' ')" Condition=" @(MSpecTestAssemblies) != '' And $(IncludeCoverage) == 'False' " IgnoreExitCode="$(ContinueOnTestError)" />

    <!-- transform mspec xml to junit xml (https://gist.github.com/Kyrodan/1183475) -->		
    <XslTransformation  XmlInputPaths="$(TestResultsDirectory)MSpecTemp.Results.%(MSpecTestAssemblies.Filename).xml" XslInputPath="$(MSpecToJUnitXsltPath)" OutputPaths="$(TestResultsDirectory)MSpec.Results.%(MSpecTestAssemblies.Filename).xml" Condition=" @(MSpecTestAssemblies) != '' And $(IncludeCoverage) == 'False' " />
    <Delete Files="$(TestResultsDirectory)MSpecTemp.Results.%(MSpecTestAssemblies.Filename).xml" Condition=" @(MSpecTestAssemblies) != '' And $(IncludeCoverage) == 'False' " />

    <!-- run tests with coverage (https://github.com/sawilde/opencover/wiki/Usage) -->
    <Exec Command="$(OpenCoverPath)OpenCover.Console.exe -register:user -returntargetcode -target:$(MSpecRunnerPath) -targetargs:&quot;--xml $(TestResultsDirectory)MSpecTemp.Results.%(MSpecTestAssemblies.Filename).xml @(MSpecTestAssemblies -> '%(Identity)', ' ')&quot; -filter:&quot;$(OpenCoverFilter)&quot; -output:$(CodeCoverageDirectory)MSpec.Coverage.%(MSpecTestAssemblies.Filename).xml" Condition=" @(MSpecTestAssemblies) != '' And $(IncludeCoverage) == 'True' " ContinueOnError="$(ContinueOnTestError)" />



    <!-- filter out test assemblies if Microsoft.VisualStudio.QualityTools.UnitTestFramework.dll is not referenced -->
    <ItemGroup>
      <MSTestTestAssemblies Remove="@(MSTestTestAssemblies)" />
      <MSTestTestAssemblies Include="%(TestAssemblies.FullPath)" Condition=" Exists('%(TestAssemblies.RelativeDir)Microsoft.VisualStudio.QualityTools.UnitTestFramework.dll') " />
    </ItemGroup>
    <Message Text="TEST ASSEMBLIES: @(TestAssemblies)"  Importance="High"/>
    <Message Text="MSTEST ASSEMBLIES: @(MSTestTestAssemblies)"  Importance="High"/>

    <!-- run tests if coverage is disabled -->
    <Exec Command="&quot;$(MSTestRunnerPath)&quot; /testcontainer:%(MSTestTestAssemblies.Identity) /resultsfile:$(TestResultsDirectory)MsTest.%(MSTestTestAssemblies.Filename).Results.xml /nologo" Condition=" @(MSTestTestAssemblies) != '' And $(IncludeCoverage) == 'False' " IgnoreExitCode="$(ContinueOnTestError)" />

    <!-- run tests with coverage (https://github.com/sawilde/opencover/wiki/Usage) -->
    <Exec Command="$(OpenCoverPath)OpenCover.Console.exe -register:user -returntargetcode -target:&quot;$(MSTestRunnerPath)&quot; -targetargs:&quot;/testcontainer:%(MSTestTestAssemblies.Identity) /resultsfile:$(TestResultsDirectory)MsTest.%(MSTestTestAssemblies.Filename).Results.xml /nologo&quot; -filter:&quot;$(OpenCoverFilter)&quot; -output:$(CodeCoverageDirectory)MSTest.Coverage.%(MSTestTestAssemblies.Filename).xml" Condition=" @(MSTestTestAssemblies) != '' And $(IncludeCoverage) == 'True' " ContinueOnError="$(ContinueOnTestError)" />


    <!-- convert coverage xml to html report (http://reportgenerator.codeplex.com/) -->
    <Exec Command="&quot;$(ReportGeneratorPath)ReportGenerator.exe&quot; &quot;-reports:$(CodeCoverageDirectory)\*.xml&quot; &quot;-targetdir:$(CodeCoverageDirectory)\&quot; -reporttypes:Html;HtmlSummary" Condition=" ( @(NunitTestAssemblies) != '' Or @(MSpecTestAssemblies) != '' Or @(MSTestTestAssemblies) != '' ) And $(IncludeCoverage) == 'True' " />

    <ItemGroup>
      <CoverageFiles Include="$(CodeCoverageDirectory)\*.xml" Exclude="$(CodeCoverageDirectory)\*.ncover.xml"/>
    </ItemGroup>	  

    <XslTransformation XmlInputPaths="%(CoverageFiles.Identity)" 
      XslInputPath="$(BuildToolsDirectory)OpenCoverTransforms\opencover_to_ncover.xslt" 
      OutputPaths="$(CodeCoverageDirectory)%(CoverageFiles.FileName).ncover.xml" Condition=" ( @(NunitTestAssemblies) != '' Or @(MSpecTestAssemblies) != '' Or @(MSTestTestAssemblies) != '' ) And $(IncludeCoverage) == 'True' " />

  </Target>


  <Target Name="RunYSlowTests">

    <Exec Command="&quot;$(PhantomJsPath)&quot; &quot;$(YSlowPath)&quot; -i grade -threshold '$(YSlowTreshold)' -f junit $(YSlowTestUrl) > $(TestResultsDirectory)yslow.xml"/>

  </Target>

  <!-- endregion Tests targets -->

  <!-- beginregion RunJMeterTests targets -->

  <Target Name="RunJMeterTests" DependsOnTargets="Clean;DownloadAndExtractJmeterToBuildTools;BeforeRunJMeterTests;CoreRunJMeterTests" />
  <Target Name="BeforeRunJMeterTests">
    <ItemGroup>
      <JMeterTestProjects Remove="@(JMeterTestProjects)" />
      <JMeterTestProjects Include="$(JMeterTestsDirectory)**\*.jmx" />
    </ItemGroup>
  </Target>
  <Target Name="CoreRunJMeterTests" Inputs="%(JMeterTestProjects.FullPath)" Outputs="AlwaysExecute">
    <ConvertToAbsolutePath Paths="$(TestResultsDirectory)%(JMeterTestProjects.Filename).log">
      <Output TaskParameter="AbsolutePaths" PropertyName="JMeterTestLogFileLocation" />
    </ConvertToAbsolutePath>

    <ConvertToAbsolutePath Paths="$(TestResultsDirectory)%(JMeterTestProjects.Filename).jtl">
      <Output TaskParameter="AbsolutePaths" PropertyName="JMeterTestOutputFileLocation" />
    </ConvertToAbsolutePath>

    <!-- start non-gui version of jmeter and pass jmx file, test output location and log file output location -->
    <Exec Command="$(JMeterToolPath) -n -t %(JMeterTestProjects.FullPath) -l $(JMeterTestOutputFileLocation) -j $(JMeterTestLogFileLocation)" Condition=" @(JMeterTestProjects) != '' " />

    <Message Text="##teamcity[importData type='junit' path='$(JMeterTestOutputFileLocation)']" />
  </Target>

  <!-- endregion RunJMeterTests targets -->	

  <!-- beginregion Release targets -->	
  <Target Name="InstallNodePackages" DependsOnTargets="BeforeInstallNodePackages;CoreInstallNodePackages" />
  <Target Name="BeforeInstallNodePackages">   
    <ItemGroup>
      <PackageJsonFiles Remove="@(PackageJsonFiles)" />
      <PackageJsonFiles Include="$(SourceDirectory)**\packag*.json" />
      <PackageJsonFiles Include="$(HtmlSourceDirectory)**\packag*.json" />
      <PackageJsonFiles Remove="$(SourceDirectory)**\node_modules\**\packag*.json" />
      <PackageJsonFiles Remove="$(HtmlSourceDirectory)**\node_modules\**\packag*.json" />
    </ItemGroup>
  </Target>
  <Target Name="CoreInstallNodePackages" Inputs="%(PackageJsonFiles.RootDir)%(PackageJsonFiles.Directory)" Outputs="AlwaysExecute">

    <ConvertToAbsolutePath Paths="%(PackageJsonFiles.RootDir)%(PackageJsonFiles.Directory)">
      <Output TaskParameter="AbsolutePaths" PropertyName="PackageJsonFileLocation" />
    </ConvertToAbsolutePath>
    <PropertyGroup>
      <NpmPath>npm.cmd</NpmPath>
    </PropertyGroup>

    <!-- npm fix with this version http://blog.npmjs.org/post/78085451721/npms-self-signed-certificate-is-no-more -->
    <Exec Command="$(NpmPath) config set ca &quot;&quot;" WorkingDirectory="$(PackageJsonFileLocation)" />

	<!-- Install Grunt in global-->
    <Exec Command="$(NpmPath) install grunt-cli -g" WorkingDirectory="$(PackageJsonFileLocation)" />

	<!-- Install Grunt in global-->
    <Exec Command="$(NpmPath) install flatten-packages -g" WorkingDirectory="$(PackageJsonFileLocation)" />

    <!-- install patch for win-spawn -->
    <Exec Command="$(NpmPath) install https://github.com/Ruzzie/win-spawn/archive/2.0.1.tar.gz" WorkingDirectory="$(PackageJsonFileLocation)" />

    <!-- npm install -->
    <Exec Command="$(NpmPath) install" WorkingDirectory="$(PackageJsonFileLocation)" />

    <!-- flatten-packages -->
    <Exec Command="flatten-packages" WorkingDirectory="$(PackageJsonFileLocation)" />

  </Target>
   
  <Target Name="RunGruntFiles" DependsOnTargets="InstallNodePackages;BeforeRunGruntFiles;CoreRunGruntFiles" />
  <Target Name="BeforeRunGruntFiles">    
    <ItemGroup>
      <GruntFiles Remove="@(GruntFiles)" />
      <GruntFiles Include="$(SourceDirectory)**\gruntfil*.js" />
      <GruntFiles Include="$(HtmlSourceDirectory)**\gruntfil*.js" />
      <GruntFiles Remove="$(SourceDirectory)**\node_modules\**\gruntfil*.js" />
      <GruntFiles Remove="$(HtmlSourceDirectory)**\node_modules\**\gruntfil*.js" />
    </ItemGroup>
  </Target>
  <Target Name="CoreRunGruntFiles" Inputs="%(GruntFiles.RootDir)%(GruntFiles.Directory)" Outputs="AlwaysExecute">

    <ConvertToAbsolutePath Paths="%(GruntFiles.RootDir)%(GruntFiles.Directory)">
      <Output TaskParameter="AbsolutePaths" PropertyName="GruntFileLocation" />
    </ConvertToAbsolutePath>  
         
      <PropertyGroup>			
      <GruntPath>grunt.cmd</GruntPath>
    </PropertyGroup>				
                          
    <!-- grunt build -->		
    <Delete Files="%(GruntFiles.RootDir)%(GruntFiles.Directory)grunt-output.txt"/>
    <Exec Timeout="120000" ContinueOnError="True" Command="$(GruntPath) build --no-color 2&gt;&amp;1&gt;grunt-output.txt" WorkingDirectory="$(GruntFileLocation)">
      <Output TaskParameter="ExitCode" PropertyName="GruntErrorCode"/>
    </Exec>
    <ReadLinesFromFile File="%(GruntFiles.RootDir)%(GruntFiles.Directory)grunt-output.txt">
       <Output TaskParameter="Lines" ItemName="OutputLines"/>
    </ReadLinesFromFile>
    <Message Text="@(OutputLines->'%(Identity)', '%0a%0d')" Condition="'$(GruntErrorCode)' == '0'"/>
    <Error Text="@(OutputLines)" Condition="'$(GruntErrorCode)' != '0'" Code="$(GruntErrorCode)"/>
      
  </Target>  
    
  <Target Name="MinifyJavaScript" DependsOnTargets="BeforeMinifyJavaScript;CoreMinifyJavaScript" Condition="'$(SkipDefaultJavascriptMinification)' == 'False'"/>
  <Target Name="BeforeMinifyJavaScript">
    <!-- remove previously minified javascript -->
    <ItemGroup>
      <OldJavaScriptFiles Include="$(MinifyRootDirectory)**\$(JavascriptDirectoryConventionName)\*.min.js" Condition=" $(MinifyJavascript) == 'True' " />
    </ItemGroup>
    <Delete Files="@(OldJavaScriptFiles)" />

    <ItemGroup>
      <JavaScriptFiles Remove="@(JavaScriptFiles)" />
      <JavaScriptFiles Include="$(MinifyRootDirectory)**\$(JavascriptDirectoryConventionName)\**\*.js" Exclude="$(MinifyRootDirectory)**\$(JavascriptDirectoryConventionName)\*.min.js" Condition=" $(MinifyJavascript) == 'True' " />
      <!-- do not include js files in the js 'root'; put your code in subdirs -->
      <JavaScriptFiles Remove="$(MinifyRootDirectory)**\$(JavascriptDirectoryConventionName)\*.js" />
    </ItemGroup>
  </Target>
  <Target Name="CoreMinifyJavaScript" Inputs="%(JavaScriptFiles.RootDir)%(JavaScriptFiles.Directory)" Outputs="AlwaysExecute">
    <MSBuild.ExtensionPack.Framework.TextString TaskAction="Split" String1="%(JavaScriptFiles.Directory)" String2="\">
      <Output ItemName="JavaScriptOutputDirectoryParts" TaskParameter="Strings" />
        </MSBuild.ExtensionPack.Framework.TextString>
    <MSBuild.ExtensionPack.Framework.MsBuildHelper TaskAction="GetLastItem" InputItems1="@(JavaScriptOutputDirectoryParts)">
            <Output TaskParameter="OutputItems" ItemName="JavaScriptSubDirectory" />
        </MSBuild.ExtensionPack.Framework.MsBuildHelper>

    <!-- minify into a single combined file per subdirectory -->
    <JavaScriptCompressorTask
      SourceFiles="@(JavaScriptFiles)"
      OutputFile="%(JavaScriptFiles.RootDir)%(JavaScriptFiles.Directory)..\@(JavaScriptSubDirectory).min.js"
      ObfuscateJavaScript="True"
      PreserveAllSemicolons="False"
      DisableOptimizations="False"
      EncodingType="UTF8"
      DeleteSourceFiles="false"
      LineBreakPosition="-1"
      LoggingType="Info"
      ThreadCulture="en-US"
      IsEvalIgnored="false"
      
      Condition=" '$(MinifyVersioningType)' == 'Both' Or '$(MinifyVersioningType)' == 'NoVersion' "
      
      />

    <!-- and a version with filenumber in the filename -->
    <JavaScriptCompressorTask
      SourceFiles="@(JavaScriptFiles)"
      OutputFile="%(JavaScriptFiles.RootDir)%(JavaScriptFiles.Directory)..\@(JavaScriptSubDirectory)$(VersionedFilePostfix).min.js"
      ObfuscateJavaScript="True"
      PreserveAllSemicolons="False"
      DisableOptimizations="False"
      EncodingType="UTF8"
      DeleteSourceFiles="false"
      LineBreakPosition="-1"
      LoggingType="Info"
      ThreadCulture="en-US"
      IsEvalIgnored="false"
      
      Condition=" '$(MinifyVersioningType)' == 'Both' Or '$(MinifyVersioningType)' == 'WithVersion' "
      
      />
      
    <!-- minify individual files -->
    <JavaScriptCompressorTask
      SourceFiles="@(JavaScriptFiles)"
      OutputFile="%(JavaScriptFiles.Identity).mintemp"
      ObfuscateJavaScript="True"
      PreserveAllSemicolons="False"
      DisableOptimizations="False"
      EncodingType="UTF8"
      DeleteSourceFiles="true"
      LineBreakPosition="-1"
      LoggingType="Info"
      ThreadCulture="en-US"
      IsEvalIgnored="false"
      />
      
    <Copy SourceFiles="%(JavaScriptFiles.Identity).mintemp" DestinationFiles="%(JavaScriptFiles.Identity)" />			
    <Delete Files="%(JavaScriptFiles.Identity).mintemp" />
    
  </Target>

  <Target Name="MinifyCss" DependsOnTargets="BeforeMinifyCss;CoreMinifyCss" Condition="'$(SkipDefaultCssMinification)' == 'False'"/>
  <Target Name="BeforeMinifyCss">		
    <!-- remove previously minified css -->
    <ItemGroup>
      <OldCssFiles Include="$(MinifyRootDirectory)**\$(CssDirectoryConventionName)\**\*.min.css" Condition=" $(MinifyCss) == 'True' " />
    </ItemGroup>
    <Delete Files="@(OldCssFiles)" />

    <ItemGroup>
      <CssFiles Remove="@(CssFiles)" />
      <CssFiles Include="$(MinifyRootDirectory)**\$(CssDirectoryConventionName)\**\*.css" Exclude="$(MinifyRootDirectory)**\$(CssDirectoryConventionName)\**\*.min.css" Condition=" $(MinifyCss) == 'True' " />
      <!-- do not include css files in the css 'root'; put your code in subdirs (it should only contain stuff like _constants.scss) -->
      <CssFiles Remove="$(MinifyRootDirectory)**\$(CssDirectoryConventionName)\*.css" />
    </ItemGroup>
  </Target>
  <Target Name="CoreMinifyCss" Inputs="%(CssFiles.RootDir)%(CssFiles.Directory)" Outputs="AlwaysExecute">
    <MSBuild.ExtensionPack.Framework.TextString TaskAction="Split" String1="%(CssFiles.Directory)" String2="\">
      <Output ItemName="CssOutputDirectoryParts" TaskParameter="Strings" />
        </MSBuild.ExtensionPack.Framework.TextString>
    <MSBuild.ExtensionPack.Framework.MsBuildHelper TaskAction="GetLastItem" InputItems1="@(CssOutputDirectoryParts)">
            <Output TaskParameter="OutputItems" ItemName="CssSubDirectory" />
        </MSBuild.ExtensionPack.Framework.MsBuildHelper>
    
    <!-- minify into a single combined file per subdirectory -->
    <CssCompressorTask
      SourceFiles="@(CssFiles)"
      OutputFile="%(CssFiles.RootDir)%(CssFiles.Directory)@(CssSubDirectory).min.css"
      CompressionType="Standard"
      EncodingType="UTF8"
      DeleteSourceFiles="false"
      LineBreakPosition="-1"
      LoggingType="Info"
      
      Condition=" '$(MinifyVersioningType)' == 'Both' Or '$(MinifyVersioningType)' == 'NoVersion' "
      
      />
      
    <!-- and a version with filenumber in the filename -->
    <CssCompressorTask
      SourceFiles="@(CssFiles)"
      OutputFile="%(CssFiles.RootDir)%(CssFiles.Directory)@(CssSubDirectory)$(VersionedFilePostfix).min.css"
      CompressionType="Standard"
      EncodingType="UTF8"
      DeleteSourceFiles="false"
      LineBreakPosition="-1"
      LoggingType="Info"
      
      Condition=" '$(MinifyVersioningType)' == 'Both' Or '$(MinifyVersioningType)' == 'WithVersion' "
      
      />
            
    <!-- minify individual files -->
    <CssCompressorTask
      SourceFiles="@(CssFiles)"
      OutputFile="%(CssFiles.Identity).mintemp"
      CompressionType="Standard"
      EncodingType="UTF8"
      DeleteSourceFiles="true"
      LineBreakPosition="-1"
      LoggingType="Info"
      />			

    <Copy SourceFiles="%(CssFiles.Identity).mintemp" DestinationFiles="%(CssFiles.Identity)" />			
    <Delete Files="%(CssFiles.Identity).mintemp" />			
      
  </Target>

  <Target Name="SassCompile" DependsOnTargets="BeforeSassCompile;CoreSassCompile" Condition=" '$(SkipDefaultSassCompile)' == 'False'"/>
  <Target Name="BeforeSassCompile">
    <ItemGroup>
      <SassFiles Remove="@(SassFiles)" />
      <SassFiles Include="$(SourceDirectory)**\$(SassDirectoryConventionName)\*.scss" Exclude="$(SourceDirectory)**\$(SassDirectoryConventionName)\_*.scss" />
    </ItemGroup>
  </Target>
  <Target Name="CoreSassCompile" Inputs="%(SassFiles.RootDir)%(SassFiles.Directory)" Outputs="AlwaysExecute">
    <PropertyGroup>
      <SassCommand>scss -f --stop-on-error --style nested </SassCommand>
      <CssOutputDirectory>%(SassFiles.RelativeDir)$(SassRelativeOutputDirectoryConventionName)</CssOutputDirectory>
    </PropertyGroup>
    <MakeDir Directories="$(CssOutputDirectory)" Condition=" !Exists('$(CssOutputDirectory)') " />
    <Exec Command="$(SassCommand) &quot;%(SassFiles.Identity)&quot; &quot;%(SassFiles.RelativeDir)$(SassRelativeOutputDirectoryConventionName)%(SassFiles.Filename).css&quot;" />
  </Target>

  <Target Name="BeforeRelease">
    <!-- remove all release artifacts from previous releases -->
    <MSBuild.ExtensionPack.FileSystem.Folder TaskAction="RemoveContent" Path="$(ReleaseDirectory)" Condition=" Exists('$(ReleaseDirectory)') " />

    <!-- make sure we do a 'rebuild' instead of 'build' -->
    <PropertyGroup>
      <CompileTarget>Clean;Rebuild</CompileTarget>
    </PropertyGroup>

    <ItemGroup>
      <AllEnvironmentsToRelease Remove="@(AllEnvironmentsToRelease)" />
    </ItemGroup>	

  </Target>
  
  <Target Name="FixUmbracoSecurityIssue" Inputs="%(ProjectsToRelease.RootDir)%(ProjectsToRelease.Directory)" Outputs="AlwaysExecute" BeforeTargets="CoreRelease"  Condition="'$(SkipUmbracoSecurityFix)' == 'False'">
    <!---file umbraco-jul-fix.ps1 -path c:\inetpub\wwwroot\YourUmbracoDir-->
    <PropertyGroup>
      <ProjectSourceDirectory>%(ProjectsToRelease.RootDir)%(ProjectsToRelease.Directory)</ProjectSourceDirectory>
    </PropertyGroup>


    <!-- resolve the temporary release directory -->
    <ConvertToAbsolutePath Paths="$(ProjectSourceDirectory)">
      <Output TaskParameter="AbsolutePaths" PropertyName="ProjectReleaseDirectory" />
    </ConvertToAbsolutePath>
    
    <Exec WorkingDirectory="$(MSBuildProjectDirectory)" Command="$(PowershellPath) -ExecutionPolicy unrestricted -f $(ScriptsDirectory)\umbraco-jul-fix.ps1 -path $(ProjectReleaseDirectory) " />

  </Target>
  
  

  <Target Name="ReleaseWebsites">

    <ItemGroup>
      <ProjectsToRelease Include="$(CSharpSourceDirectory)**\*.$(WebsiteProjectConventionName).csproj">
        <UseAspNetCompilerForRelease>$(UseAspNetCompilerForRelease)</UseAspNetCompilerForRelease>
        <FilesToCopyForWebsiteReleasePattern>$(FilesToCopyForWebsiteReleasePattern)</FilesToCopyForWebsiteReleasePattern>
        <FilesToRemoveForWebsiteReleasePattern>$(FilesToRemoveForWebsiteReleasePattern)</FilesToRemoveForWebsiteReleasePattern>
        <FilesToCopyForReleasePattern></FilesToCopyForReleasePattern>
        <TargetConfigExtension>dll.config</TargetConfigExtension>
      </ProjectsToRelease>
    </ItemGroup>	
  </Target>

  <Target Name="ReleaseWebServices">
    <ItemGroup>
      <ProjectsToRelease Include="$(CSharpSourceDirectory)**\*.$(WebServiceProjectConventionName).csproj">
        <UseAspNetCompilerForRelease>True</UseAspNetCompilerForRelease>
        <FilesToCopyForReleasePattern></FilesToCopyForReleasePattern>
        <TargetConfigExtension>dll.config</TargetConfigExtension>
      </ProjectsToRelease>
    </ItemGroup>	
  </Target>

  <Target Name="ReleaseStaticHtml">
    <ItemGroup>
      <ProjectsToRelease Include="$(HtmlSourceDirectory)**\*.$(StaticHtmlProjectConventionName)\$(StaticHtmlFileConventionName)">				
        <FilesToCopyForReleasePattern>**\*</FilesToCopyForReleasePattern>				
        <TargetConfigExtension>dll.config</TargetConfigExtension>
      </ProjectsToRelease>			
    </ItemGroup>	
  </Target>	

  <Target Name="ReleaseConsoleApps">
    <ItemGroup>
      <ProjectsToRelease Include="$(CSharpSourceDirectory)**\*.$(ConsoleAppProjectConventionName).csproj">				
        <FilesToCopyForReleasePattern>bin\$(Configuration)\*</FilesToCopyForReleasePattern>
        <TargetConfigExtension>exe.config</TargetConfigExtension>
      </ProjectsToRelease>
    </ItemGroup>	
  </Target>

  <Target Name="ReleaseServices">
    <ItemGroup>
      <ProjectsToRelease Include="$(CSharpSourceDirectory)**\*.$(WindowsServiceProjectConventionName).csproj">				
        <FilesToCopyForReleasePattern>bin\$(Configuration)\*</FilesToCopyForReleasePattern>
        <TargetConfigExtension>exe.config</TargetConfigExtension>
      </ProjectsToRelease>
    </ItemGroup>	
  </Target>

  <Target Name="ReleaseWorkers">
    <ItemGroup>
      <ProjectsToRelease Include="$(CSharpSourceDirectory)**\*.$(WorkerProjectConventionName).csproj">				
        <FilesToCopyForReleasePattern>bin\$(Configuration)\*</FilesToCopyForReleasePattern>
        <TargetConfigExtension>dll.config</TargetConfigExtension>
      </ProjectsToRelease>
    </ItemGroup>	
  </Target>

  <Target Name="ReleaseDatabases">
    <ItemGroup>
      <ProjectsToRelease Include="$(CSharpSourceDirectory)**\*.$(DatabaseProjectConventionName).dbproj">				
        <FilesToCopyForReleasePattern>sql\$(Configuration)\*</FilesToCopyForReleasePattern>
      </ProjectsToRelease>
      <ProjectsToRelease Include="$(CSharpSourceDirectory)**\*.$(DatabaseProjectConventionName).sqlproj">
        <UseAspNetCompilerForRelease>False</UseAspNetCompilerForRelease>
        <FilesToCopyForReleasePattern>bin\$(Configuration)\*</FilesToCopyForReleasePattern>
      </ProjectsToRelease>
    </ItemGroup>			
  </Target>

  <Target Name="ReleaseDatabasesViaTool">
    <ItemGroup>
      <ProjectsToRelease Include="$(DatabaseDirectory)**\connection.config">
        <FilesToCopyForReleasePattern>**\*</FilesToCopyForReleasePattern>
      </ProjectsToRelease>
    </ItemGroup>
  </Target>

  <Target Name="CoreRelease" Inputs="%(ProjectsToRelease.RootDir)%(ProjectsToRelease.Directory)%(ProjectsToRelease.Environment)" Outputs="AlwaysExecute">
    <PropertyGroup>
      <ProjectSourceDirectory>%(ProjectsToRelease.RootDir)%(ProjectsToRelease.Directory)</ProjectSourceDirectory>
      <UseAspNetCompilerForRelease>%(ProjectsToRelease.UseAspNetCompilerForRelease)</UseAspNetCompilerForRelease>
      <FilesToCopyForReleasePattern>%(ProjectsToRelease.FilesToCopyForReleasePattern)</FilesToCopyForReleasePattern>
      <FilesToCopyForWebsiteReleasePattern>%(ProjectsToRelease.FilesToCopyForWebsiteReleasePattern)</FilesToCopyForWebsiteReleasePattern>
      <FilesToRemoveForWebsiteReleasePattern>%(ProjectsToRelease.FilesToRemoveForWebsiteReleasePattern)</FilesToRemoveForWebsiteReleasePattern>
    </PropertyGroup>

    <ItemGroup>
      <ProjectName Remove="@(ProjectName)" />
    </ItemGroup>

    <!-- get project name -->
    <MSBuild.ExtensionPack.Framework.TextString TaskAction="Split" String1="$(ProjectSourceDirectory)" String2="\">
      <Output ItemName="ProjectSourceDirectoryParts" TaskParameter="Strings" />
        </MSBuild.ExtensionPack.Framework.TextString>
    <MSBuild.ExtensionPack.Framework.MsBuildHelper TaskAction="GetLastItem" InputItems1="@(ProjectSourceDirectoryParts)">
            <Output TaskParameter="OutputItems" ItemName="ProjectName" />
        </MSBuild.ExtensionPack.Framework.MsBuildHelper>			

    <PropertyGroup>
      <ProjectName>@(ProjectName)</ProjectName>
      <RelativeProjectReleaseDirectory>$(ProjectName)\</RelativeProjectReleaseDirectory>
    </PropertyGroup>			

    <!-- resolve the temporary release directory -->
    <ConvertToAbsolutePath Paths="$(ReleaseTempDirectory)$(RelativeProjectReleaseDirectory)">
      <Output TaskParameter="AbsolutePaths" PropertyName="ProjectReleaseDirectory" />
    </ConvertToAbsolutePath>

    <!-- remove obj directory from build directory, otherwise aspnetcompiler might fail due to multiple web.configs -->
    <MSBuild.ExtensionPack.FileSystem.Folder TaskAction="RemoveContent" Path="%(ProjectsToRelease.RelativeDir)obj" Condition=" Exists('%(ProjectsToRelease.RelativeDir)obj') " />
    <RemoveDir Directories="%(ProjectsToRelease.RelativeDir)obj" Condition=" Exists('%(ProjectsToRelease.RelativeDir)obj') " />

    <!-- if it has a web.config and UseAspNetCompilerForRelease is true let aspnetcompiler precompile the project  -->
    <AspNetCompiler VirtualPath="/" PhysicalPath="$(ProjectSourceDirectory)" TargetPath="$(ProjectReleaseDirectory)" Updateable="$(CreateUpdateableAspxFilesInRelease)" Condition=" $(UseAspNetCompilerForRelease) == 'True' " />

    <!-- otherwise copy the files and dirs defined in FilesToCopyForReleasePattern or FilesToCopyForWebsiteReleasePattern (for websites) to the temp folder -->
    <ItemGroup>
      <FilesToCopy Remove="@(FilesToCopy)" />
      <FilesToCopy Include="$(ProjectSourceDirectory)$(FilesToCopyForReleasePattern)" Condition=" $(FilesToCopyForReleasePattern) != '' " />
      <FilesToCopy Include="$(ProjectSourceDirectory)$(FilesToCopyForWebsiteReleasePattern)" Condition=" $(FilesToCopyForWebsiteReleasePattern) != '' And $(UseAspNetCompilerForRelease) != 'True' " />
    </ItemGroup>
    <Copy SourceFiles="@(FilesToCopy)" DestinationFolder="$(ProjectReleaseDirectory)%(FilesToCopy.RecursiveDir)" Condition=" @(FilesToCopy) != '' " />	

    <Exec Command="COPY /Y $(ProjectSourceDirectory)$(CssFilesToCopyAfterCopySourcePattern) $(ProjectReleaseDirectory)$(CssFilesToCopyAfterCopyReleaseDestination)" Condition=" @(FilesToCopy) != '' AND $(CssFilesToCopyAfterCopySourcePattern) != '' AND $(CssFilesToCopyAfterCopyReleaseDestination) != ''">
      <Output TaskParameter="ExitCode" PropertyName="Exit"/>
    </Exec>
	<Error Condition = " $(CssFilesToCopyAfterCopySourcePattern) != '' AND $(CssFilesToCopyAfterCopyReleaseDestination) != '' AND '$(Exit)' != '0'" Text="CssCopyAfterCopy failed." />

    <!-- remove (user defined) files from release directory -->
    <MSBuild.ExtensionPack.Framework.TextString TaskAction="Split" String1="$(FilesToRemoveForWebsiteReleasePattern)" String2=";" Condition=" $(FilesToRemoveForWebsiteReleasePattern) != '' ">
      <Output ItemName="FilesToRemoveForWebsiteRelease" TaskParameter="Strings" />
        </MSBuild.ExtensionPack.Framework.TextString>
    <ItemGroup>
      <FilesToRemove Remove="@(FilesToRemove)" />
      <FilesToRemove Include="$(ProjectReleaseDirectory)%(FilesToRemoveForWebsiteRelease.Identity)" />
    </ItemGroup>
    <Delete Files="@(FilesToRemove)" />

    <!-- remove project files and web.config transform files from release directory -->
    <ItemGroup>
      <FilesToRemoveFromReleaseDirectory Remove="@(FilesToRemoveFromReleaseDirectory)" />
      <FilesToRemoveFromReleaseDirectory Include="$(ProjectReleaseDirectory)*.csproj*" />
      <FilesToRemoveFromReleaseDirectory Include="$(ProjectReleaseDirectory)packages.config" />
      <FilesToRemoveFromReleaseDirectory Include="$(ProjectReleaseDirectory)**\*.settings" />
      <FilesToRemoveFromReleaseDirectory Include="$(ProjectReleaseDirectory)**\*.scss" />
      <FilesToRemoveFromReleaseDirectory Include="$(ProjectReleaseDirectory)**\*.scssc" />
      <FilesToRemoveFromReleaseDirectory Include="$(ProjectReleaseDirectory)**\*.*.config" />
      <FilesToRemoveFromReleaseDirectory Include="$(ProjectReleaseDirectory)*.snk" />
      <FilesToRemoveFromReleaseDirectory Include="$(ProjectReleaseDirectory)obj\**\*" />
      <FilesToRemoveFromReleaseDirectory Include="$(ProjectReleaseDirectory)_ReSharper*\**\*" />
      <FilesToRemoveFromReleaseDirectory Include="$(ProjectReleaseDirectory)*ReSharper*" />
      <FilesToRemoveFromReleaseDirectory Include="$(ProjectReleaseDirectory)*.sln" />
      <FilesToRemoveFromReleaseDirectory Include="$(ProjectReleaseDirectory)**\.svn\**\*" />
      <FilesToRemoveFromReleaseDirectory Include=".git*" />
      <FilesToRemoveFromReleaseDirectory Include="$(ProjectReleaseDirectory)**\.sonar\**\*" />
      <FilesToRemoveFromReleaseDirectory Include="$(ProjectReleaseDirectory)*.sublime-*" />			
      <FilesToRemoveFromReleaseDirectory Include="$(ProjectReleaseDirectory)**\$(GruntBuildFileConventionName)" />			
      <FilesToRemoveFromReleaseDirectory Include="$(ProjectReleaseDirectory)**\.sass-cache\**" />			
      <FilesToRemoveFromReleaseDirectory Include="$(ProjectReleaseDirectory)**\node_modules\**" />			
      <FilesToRemoveFromReleaseDirectory Include="$(ProjectReleaseDirectory)**\package.json" />
    </ItemGroup>
    <Delete Files="@(FilesToRemoveFromReleaseDirectory)" />

    <!-- update version number inside js and css files -->
    <ItemGroup>
      <AllStaticFiles Remove="@(AllStaticFiles)" />
      <AllStaticFiles Include="$(ProjectReleaseDirectory)$(CssDirectoryConventionName)\**\*.css" />
      <AllStaticFiles Include="$(ProjectReleaseDirectory)$(JavascriptDirectoryConventionName)\**\*.js" />
      <AllStaticFiles Include="$(ProjectReleaseDirectory)**\*.html" />
    </ItemGroup>

    <Attrib ReadOnly="false" Files="@(AllStaticFiles)" Condition="'$(SkipSetVersionNumberInStaticFiles)' == 'False'" />
    <FileUpdate Files="@(AllStaticFiles)" Regex="1\.0\.0\.0" ReplacementText="$(BuildVersion)" Condition=" '$(SkipSetVersionNumberInStaticFiles)' == 'False' AND @(AllStaticFiles) != '' " />

    <!-- remove debug sections -->
    <FileUpdate Files="@(AllStaticFiles)" Regex="(&lt;!-- begin debug --&gt;.*?&lt;!-- end debug --&gt;)|(&lt;!-- begin release)|(end release --&gt;)" ReplacementText=" " Singleline="True" Multiline="True" Condition=" '$(SkipSetVersionNumberInStaticFiles)' == 'False' AND @(AllStaticFiles) != '' " />		

    <!-- minify css and javascript within the temp directory; use trick to execute the targets for each project to release -->		
    <MSBuild Projects="$(ScriptsDirectory)targets.msbuild" Targets="MinifyJavaScript;MinifyCss" Properties="FakeProperty=%(ProjectsToRelease.RootDir)%(ProjectsToRelease.Directory)%(ProjectsToRelease.Environment)" Condition="'$(SkipDefaultJavascriptMinification)' == 'False'"/>
    
    <!-- optimize all jpegs -->
    <ItemGroup>
      <AllJpegFiles Remove="@(AllJpegFiles)" />
      <AllJpegFiles Include="$(ProjectReleaseDirectory)**\*.jpg" />
      <AllJpegFiles Include="$(ProjectReleaseDirectory)**\*.jpeg" />
    </ItemGroup>
    <Exec Command="&quot;$(JpegtranPath)&quot; -progressive -optimize &quot;%(AllJpegFiles.FullPath)&quot; &quot;%(AllJpegFiles.FullPath)&quot;" Condition=" @(AllJpegFiles) != '' And $(OptimizeImages) " />

    <!-- optimize all pngs -->
    <ItemGroup>
      <AllPngFiles Remove="@(AllPngFiles)" />
      <AllPngFiles Include="$(ProjectReleaseDirectory)**\*.png" />
    </ItemGroup>
    <Exec Command="&quot;$(OptiPngPath)&quot; &quot;%(AllPngFiles.FullPath)&quot;" Condition=" @(AllPngFiles) != '' And $(OptimizeImages) " />
    
    <!-- determine all environments from *.*.config -->
    <ItemGroup>
      <AllEnvironmentTransforms Remove="@(AllEnvironmentTransforms)" />
      <AllEnvironmentTransforms Include="$(ProjectSourceDirectory)*.*.config" />

      <__AllEnvironments Remove="@(__AllEnvironments)" />
      <__AllEnvironments Include="$(SuitedForAllEnvironmentsDirectoryName)" Condition=" @(AllEnvironmentTransforms) == '' " />
      <__AllEnvironments Include="$([System.String]::Copy('%(AllEnvironmentTransforms.Filename)').Split('.')[1])" Condition=" @(AllEnvironmentTransforms) != '' " />
      <_AllEnvironments Remove="@(AllEnvironments)" />
      <AllEnvironments Remove="@(AllEnvironments)" />

      <_AllConfigsWithTransforms Remove="@(_AllConfigsWithTransforms)" />
      <_AllConfigsWithTransforms Include="$([System.String]::Copy('%(AllEnvironmentTransforms.Filename)').Split('.')[0])" Condition=" @(AllEnvironmentTransforms) != '' " />
      <AllConfigsWithTransforms Remove="@(AllConfigsWithTransforms)" />
    </ItemGroup>

    <!-- remove duplicates -->
        <MSBuild.ExtensionPack.Framework.MsBuildHelper TaskAction="RemoveDuplicateFiles" InputItems1="@(__AllEnvironments)">
            <Output TaskParameter="OutputItems" ItemName="_AllEnvironments"/>
        </MSBuild.ExtensionPack.Framework.MsBuildHelper>
        <MSBuild.ExtensionPack.Framework.MsBuildHelper TaskAction="RemoveDuplicateFiles" InputItems1="@(_AllConfigsWithTransforms)" Condition=" @(_AllConfigsWithTransforms) != '' ">
            <Output TaskParameter="OutputItems" ItemName="AllConfigsWithTransforms"/>
        </MSBuild.ExtensionPack.Framework.MsBuildHelper>

    <!--  remove environments that are not in @(ConfigurationsToRelease) -->
        <MSBuild.ExtensionPack.Framework.MsBuildHelper TaskAction="GetCommonItems" InputItems1="@(_AllEnvironments)" InputItems2="@(ConfigurationsToRelease)" Condition=" @(ConfigurationsToRelease) != '' " >
            <Output TaskParameter="OutputItems" ItemName="AllEnvironments"/>
        </MSBuild.ExtensionPack.Framework.MsBuildHelper>
    <!--  or keep all environments if @(ConfigurationsToRelease) is empty -->
    <ItemGroup>
      <AllEnvironments Include="@(_AllEnvironments)" Condition=" @(ConfigurationsToRelease) == '' " />
      <AllEnvironmentsToRelease Include="@(AllEnvironments)" />
    </ItemGroup>

    <ItemGroup>
      <ConfigsToTransform Remove="@(ConfigsToTransform)" />
      <ConfigsToTransform Include="@(AllConfigsWithTransforms)">
        <Environment>%(AllEnvironments.Identity)</Environment>
      </ConfigsToTransform>
    </ItemGroup>

    <!-- add Mirabeau database release tool; only when 'project' to release is database folder -->
    <Copy SourceFiles="$(MirabeauDatabaseReleaseToolPath)" DestinationFolder="$(ProjectReleaseDirectory)" Condition="$([System.String]::Copy('%(ProjectsToRelease.FullPath)').Contains('connection.config'))" />

    <!-- copy everything from temp directory to release directory and then remove temp directory; this is to ensure no empty directories end up in the release -->
    <ItemGroup>
      <FilesToMove Remove="@(FilesToMove)" />
      <FilesToMove Include="$(ReleaseTempDirectory)**">
        <Environment>%(AllEnvironments.Identity)</Environment>
      </FilesToMove>
    </ItemGroup>

    <!-- copy files to a separate directory for each environment and update version number in filenames -->
    <Copy SourceFiles="@(FilesToMove)" DestinationFiles="$(ReleaseDirectory)%(FilesToMove.Environment)\%(FilesToMove.RecursiveDir)$([System.String]::Copy('%(FilesToMove.Filename)').Replace('1.0.0.0',$(BuildVersion)))%(FilesToMove.Extension)" />

    <!-- create release directory if it does not exist yet -->
    <MakeDir Directories="$(ReleaseDirectory)%(AllEnvironments.Identity)\$(RelativeProjectReleaseDirectory)" Condition=" !Exists('$(ReleaseDirectory)%(AllEnvironments.Identity)\$(RelativeProjectReleaseDirectory)') " />

    <!-- transform *.config -->
    <TransformXml Source="$(ProjectSourceDirectory)%(ConfigsToTransform.Identity).config" Transform="$(ProjectSourceDirectory)%(ConfigsToTransform.Identity).%(ConfigsToTransform.Environment).config" Destination="$(ReleaseDirectory)%(ConfigsToTransform.Environment)\$(RelativeProjectReleaseDirectory)%(ConfigsToTransform.Identity).config" Condition=" Exists('$(ProjectSourceDirectory)%(ConfigsToTransform.Identity).%(ConfigsToTransform.Environment).config') " StackTrace="true" />

    <!-- rename transformed app.config to *.dll.config or *.exe.config -->
    <PropertyGroup>
      <DllConfigName>%(ProjectsToRelease.Filename).%(ProjectsToRelease.TargetConfigExtension)</DllConfigName>
    </PropertyGroup>
    <ItemGroup>
      <AppConfigToMove Remove="@(AppConfigToMove)" />
      <AppConfigToMove Include="$(ReleaseDirectory)%(ConfigsToTransform.Environment)\$(RelativeProjectReleaseDirectory)App.config" Condition=" Exists('$(ReleaseDirectory)%(ConfigsToTransform.Environment)\$(RelativeProjectReleaseDirectory)App.config') ">
        <TargetFile>$(ReleaseDirectory)%(ConfigsToTransform.Environment)\$(RelativeProjectReleaseDirectory)$(DllConfigName)</TargetFile>
        <TargetFile Condition=" Exists('$(ReleaseDirectory)%(ConfigsToTransform.Environment)\$(RelativeProjectReleaseDirectory)bin\') ">$(ReleaseDirectory)%(ConfigsToTransform.Environment)\$(RelativeProjectReleaseDirectory)bin\$(DllConfigName)</TargetFile>
      </AppConfigToMove>
    </ItemGroup>		
    <Copy SourceFiles="%(AppConfigToMove.FullPath)" DestinationFiles="%(AppConfigToMove.TargetFile)" />
    <Delete Files="%(AppConfigToMove.FullPath)" />

    <!-- determine whether there are other (than the ones in the project directory) configuration files that need to be transformed -->
    <ItemGroup>
      <OtherConfigFiles Remove="@(OtherConfigFiles)" />
      <OtherConfigFiles Include="$(ProjectSourceDirectory)**\*.%(AllEnvironments.Identity).config">
        <Environment>%(AllEnvironments.Identity)</Environment>
      </OtherConfigFiles>
      <OtherConfigFiles Remove="$(ProjectSourceDirectory)%(ConfigsToTransform.Identity).%(ConfigsToTransform.Environment).config" />
    </ItemGroup>
    <Message Text="OtherConfigFiles: [@(OtherConfigFiles)]" />

    <!-- transform *.config -->
    <TransformXml Source="$([System.String]::Copy('%(OtherConfigFiles.FullPath)').Replace('.%(OtherConfigFiles.Environment)', ''))" Transform="%(OtherConfigFiles.FullPath)" Destination="$(ReleaseDirectory)%(OtherConfigFiles.Environment)\$(RelativeProjectReleaseDirectory)%(OtherConfigFiles.RecursiveDir)$([System.String]::Copy('%(OtherConfigFiles.Filename)').Replace('.%(OtherConfigFiles.Environment)', '')).config" Condition=" Exists('%(OtherConfigFiles.FullPath)') " StackTrace="true" />

    <!-- remove temporary directory -->
    <MSBuild.ExtensionPack.FileSystem.Folder TaskAction="RemoveContent" Path="$(ReleaseTempDirectory)" Condition=" Exists('$(ReleaseTempDirectory)') " />
    <RemoveDir Directories="$(ReleaseTempDirectory)" />

    <!-- zip release directory and store zip with version number one directory above -->
    <ItemGroup>
      <FilesToZip Remove="@(FilesToZip)" />
      <FilesToZip Include="$(ReleaseDirectory)%(AllEnvironments.Identity)\$(RelativeProjectReleaseDirectory)**\*"> 
        <Environment>%(AllEnvironments.Identity)</Environment>
      </FilesToZip>
    </ItemGroup>

    <Zip Files="@(FilesToZip)" WorkingDirectory="$(ReleaseDirectory)%(FilesToZip.Environment)\$(RelativeProjectReleaseDirectory)" ZipFileName="$(ReleaseDirectory)%(FilesToZip.Environment)\@(ProjectName)-%(FilesToZip.Environment)-$(BuildVersion).zip" ParallelCompression="false" ZipLevel="6" />

    <ItemGroup>
      <ReleaseDirectoriesToRemove Include="$(ReleaseDirectory)%(AllEnvironments.Identity)\$(ProjectName)" />
    </ItemGroup>

  </Target>

  <Target Name="ReleaseAzure" DependsOnTargets="_BeforeReleaseAzure;BeforeReleaseAzure;CoreReleaseAzure" />
  <Target Name="_BeforeReleaseAzure">
    <ItemGroup>
      <_AzureToRelease Include="$(CSharpSourceDirectory)**\*.$(AzureProjectConventionName).ccproj" />
    </ItemGroup>	
  </Target>
  <Target Name="BeforeReleaseAzure" Inputs="%(_AzureToRelease.RootDir)%(_AzureToRelease.Directory)" Outputs="AlwaysExecute">

    <PropertyGroup>
      <ProjectSourceDirectory>%(_AzureToRelease.RootDir)%(_AzureToRelease.Directory)</ProjectSourceDirectory>
    </PropertyGroup>

    <Message Text="ProjectSourceDirectory : $(ProjectSourceDirectory)" />

    <!-- determine all environments from *.*.cscfg -->
    <ItemGroup>
      <AllEnvironmentTransforms Remove="@(AllEnvironmentTransforms)" />
      <AllEnvironmentTransforms Include="$(ProjectSourceDirectory)ServiceConfiguration.*.cscfg" />

      <__AllEnvironments Remove="@(__AllEnvironments)" />
      <__AllEnvironments Include="$(SuitedForAllEnvironmentsDirectoryName)" Condition=" @(AllEnvironmentTransforms) == '' " />
      <__AllEnvironments Include="$([System.String]::Copy('%(AllEnvironmentTransforms.Filename)').Split('.')[1])" Condition=" @(AllEnvironmentTransforms) != '' " />
      <_AllEnvironments Remove="@(AllEnvironments)" />
      <AllEnvironments Remove="@(AllEnvironments)" />			
    </ItemGroup>

    <!-- remove duplicates -->
        <MSBuild.ExtensionPack.Framework.MsBuildHelper TaskAction="RemoveDuplicateFiles" InputItems1="@(__AllEnvironments)">
            <Output TaskParameter="OutputItems" ItemName="_AllEnvironments"/>
        </MSBuild.ExtensionPack.Framework.MsBuildHelper>

    <!--  remove environments that are not in @(ConfigurationsToRelease) -->
        <MSBuild.ExtensionPack.Framework.MsBuildHelper TaskAction="GetCommonItems" InputItems1="@(_AllEnvironments)" InputItems2="@(ConfigurationsToRelease)" Condition=" @(ConfigurationsToRelease) != '' " >
            <Output TaskParameter="OutputItems" ItemName="AllEnvironments"/>
        </MSBuild.ExtensionPack.Framework.MsBuildHelper>
    <!--  or keep all environments if @(ConfigurationsToRelease) is empty -->
    <ItemGroup>
      <AllEnvironments Include="@(_AllEnvironments)" Condition=" @(ConfigurationsToRelease) == '' " />
      <AllEnvironmentsToRelease Include="@(AllEnvironments)" />
    </ItemGroup>

    <!-- not sure if this works properly if different azure projects have different environment transforms -->
    <ItemGroup>
      <AzureToRelease Include="@(_AzureToRelease)">
        <Environment>%(AllEnvironments.Identity)</Environment>
      </AzureToRelease>
    </ItemGroup>

    <Message Text="AzureToRelease : @(AzureToRelease)" />

  </Target>
  <Target Name="CoreReleaseAzure" Inputs="%(AzureToRelease.RootDir)%(AzureToRelease.Directory)%(AzureToRelease.Environment)" Outputs="AlwaysExecute">

    <PropertyGroup>
      <ProjectSourceDirectory>%(AzureToRelease.RootDir)%(AzureToRelease.Directory)</ProjectSourceDirectory>
    </PropertyGroup>

    <ItemGroup>
      <ProjectName Remove="@(ProjectName)" />
    </ItemGroup>

    <!-- get project name -->
    <MSBuild.ExtensionPack.Framework.TextString TaskAction="Split" String1="$(ProjectSourceDirectory)" String2="\">
      <Output ItemName="ProjectSourceDirectoryParts" TaskParameter="Strings" />
    </MSBuild.ExtensionPack.Framework.TextString>
    <MSBuild.ExtensionPack.Framework.MsBuildHelper TaskAction="GetLastItem" InputItems1="@(ProjectSourceDirectoryParts)">
      <Output TaskParameter="OutputItems" ItemName="ProjectName" />
    </MSBuild.ExtensionPack.Framework.MsBuildHelper>			

    <!-- resolve the release directory -->
    <PropertyGroup>
      <ProjectName>@(ProjectName)</ProjectName>
      <RelativeProjectReleaseDirectory>$(ProjectName)\</RelativeProjectReleaseDirectory>
    </PropertyGroup>

    <!-- remove bin and obj folders -->
    <ItemGroup>
      <DirectoriesToRemove Remove="@(DirectoriesToRemove)" />
      <DirectoriesToRemove Include="%(AzureToRelease.RelativeDir)obj" />
      <DirectoriesToRemove Include="%(AzureToRelease.RelativeDir)bin" />
    </ItemGroup>

    <MSBuild.ExtensionPack.FileSystem.Folder TaskAction="RemoveContent" Path="%(DirectoriesToRemove.FullPath)" Condition=" Exists('%(DirectoriesToRemove.FullPath)') " />
    <RemoveDir Directories="@(DirectoriesToRemove)" />

    <!-- convert all relative directory paths to absolute paths -->
    <ConvertToAbsolutePath Paths="$(ReleaseDirectory)%(AzureToRelease.Environment)\">
      <Output TaskParameter="AbsolutePaths" PropertyName="AbsoluteReleaseDirectory" />
    </ConvertToAbsolutePath>

    <!-- backup ServiceDefinition.csdef -->
    <Copy SourceFiles="$(ProjectSourceDirectory)ServiceDefinition.csdef" DestinationFiles="$(ProjectSourceDirectory)ServiceDefinition.csdef.original" />

    <!-- transform ServiceDefinition.csdef -->
    <TransformXml Source="$(ProjectSourceDirectory)ServiceDefinition.csdef.original" Destination="$(ProjectSourceDirectory)ServiceDefinition.csdef" Transform="$(ProjectSourceDirectory)ServiceDefinition.%(AzureToRelease.Environment).csdef" Condition=" Exists('$(ProjectSourceDirectory)ServiceDefinition.%(AzureToRelease.Environment).csdef') " />

    <!-- backup ServiceConfiguration.cscfg -->
    <Copy SourceFiles="$(ProjectSourceDirectory)ServiceConfiguration.cscfg" DestinationFiles="$(ProjectSourceDirectory)ServiceConfiguration.cscfg.original" />

    <!-- transform ServiceConfiguration.cscfg -->
    <TransformXml Source="$(ProjectSourceDirectory)ServiceConfiguration.cscfg.original" Destination="$(ProjectSourceDirectory)ServiceConfiguration.cscfg" Transform="$(ProjectSourceDirectory)ServiceConfiguration.%(AzureToRelease.Environment).cscfg" Condition=" Exists('$(ProjectSourceDirectory)ServiceConfiguration.%(AzureToRelease.Environment).cscfg') " />      
       
    <!-- create the azure package, with transformed ServiceDefinition.csdef -->
    <MsBuild Projects="%(AzureToRelease.FullPath)" Targets="Publish" Properties="$(BuildParameters);AbsoluteReleaseDirectory=$(AbsoluteReleaseDirectory)" BuildInParallel="true" />

    <!-- copy the azure package and ServiceConfiguration.cscfg to release directory -->
    <ItemGroup>
      <ReleaseFilesToCopy Remove="@(ReleaseFilesToCopy)" />
      <ReleaseFilesToCopy Include="$(ProjectSourceDirectory)bin\$(Configuration)\app.publish\**\*">
        <Environment>%(AzureToRelease.Environment)</Environment>
      </ReleaseFilesToCopy>
    </ItemGroup>
    <Copy SourceFiles="@(ReleaseFilesToCopy)" DestinationFolder="$(ReleaseDirectory)%(ReleaseFilesToCopy.Environment)\$(RelativeProjectReleaseDirectory)%(ReleaseFilesToCopy.RecursiveDir)" />

    <!-- restore ServiceConfiguration.cscfg -->
    <Copy SourceFiles="$(ProjectSourceDirectory)ServiceConfiguration.cscfg.original" DestinationFiles="$(ProjectSourceDirectory)ServiceConfiguration.cscfg" Retries="30" RetryDelayMilliseconds="5000" />

    <!-- delete ServiceConfiguration.cscfg.original -->
    <Delete Files="$(ProjectSourceDirectory)ServiceConfiguration.cscfg.original" />
      
    <!-- transform ServiceConfiguration.cscfg for environment -->
    <TransformXml Source="$(ProjectSourceDirectory)ServiceConfiguration.cscfg" Destination="$(ReleaseDirectory)%(AzureToRelease.Environment)\$(RelativeProjectReleaseDirectory)ServiceConfiguration.cscfg" Transform="$(ProjectSourceDirectory)ServiceConfiguration.%(AzureToRelease.Environment).cscfg" Condition=" Exists('$(ProjectSourceDirectory)ServiceConfiguration.%(AzureToRelease.Environment).cscfg') And Exists('$(ProjectSourceDirectory)ServiceConfiguration.cscfg') " />
       
    <!-- restore ServiceDefinition.csdef -->
    <Copy SourceFiles="$(ProjectSourceDirectory)ServiceDefinition.csdef.original" DestinationFiles="$(ProjectSourceDirectory)ServiceDefinition.csdef" Retries="30" RetryDelayMilliseconds="5000" />

    <!-- delete ServiceDefinition.csdef.original -->
    <Delete Files="$(ProjectSourceDirectory)ServiceDefinition.csdef.original" />

    <!-- zip release directory and store zip with version number one directory above -->
    <ItemGroup>
      <ProjectName Remove="@(ProjectName)" />
      <FilesToZip Remove="@(FilesToZip)" />
      <FilesToZip Include="$(ReleaseDirectory)%(ReleaseFilesToCopy.Environment)\$(RelativeProjectReleaseDirectory)%(ReleaseFilesToCopy.RecursiveDir)\**\*"> 
        <Environment>%(ReleaseFilesToCopy.Environment)</Environment>
      </FilesToZip>
    </ItemGroup>

    <Zip Files="@(FilesToZip)" WorkingDirectory="$(ReleaseDirectory)%(FilesToZip.Environment)\$(RelativeProjectReleaseDirectory)" ZipFileName="$(ReleaseDirectory)%(FilesToZip.Environment)\$(ProjectName)-%(FilesToZip.Environment)-$(BuildVersion).zip" ZipLevel="9" />

    <ItemGroup>
      <ReleaseDirectoriesToRemove Include="$(ReleaseDirectory)%(ReleaseFilesToCopy.Environment)\$(ProjectName)" />
    </ItemGroup>		

  </Target>

  <Target Name="ReleaseNugetPackages" DependsOnTargets="BeforeReleaseNugetPackage;CoreReleaseNugetPackage" />
  <Target Name="BeforeReleaseNugetPackage">
    <ItemGroup>
      <NuGetToRelease Include="$(CSharpSourceDirectory)**\*.$(NugetProjectConventionName).csproj" />
      <NuGetToRelease Include="$(CSharpSourceDirectory)**\$(NugetProjectToRelease).csproj" Condition=" $(NugetProjectToRelease) != '' " />
    </ItemGroup>	

    <Message Text="NuGetToRelease: @(NuGetToRelease)" />
  </Target>
  <Target Name="CoreReleaseNugetPackage" Inputs="%(NuGetToRelease.RootDir)%(NuGetToRelease.Directory)" Outputs="AlwaysExecute">

    <!-- create release directory -->
    <MakeDir Directories="$(ReleaseDirectory)$(NuGetDirectoryName)" />

    <!-- create the package -->
    <Exec Command="&quot;$(NuGetPath)&quot; pack &quot;%(NuGetToRelease.RelativeDir)%(NuGetToRelease.Filename)%(NuGetToRelease.Extension)&quot; -OutputDirectory $(ReleaseDirectory)$(NuGetDirectoryName) -Version $(BuildVersion) -Properties Configuration=$(Configuration)" />

    <ItemGroup>
      <AllEnvironmentsToRelease Include="$(NuGetDirectoryName)" />
    </ItemGroup>

  </Target>

  <Target Name="AfterRelease">

    <ItemGroup>
      <AllProjectsToRelease Remove="@(AllProjectsToRelease)" />
      <AllProjectsToRelease Include="@(ProjectsToRelease)" />
      <AllProjectsToRelease Include="@(AzureToRelease)" />
      <AllProjectsToRelease Include="@(NuGetToRelease)" />
    </ItemGroup>	

    <!-- throw an error if there was nothing to release -->
    <Error Text="There are no projects to be released!" Condition=" @(AllProjectsToRelease) == '' " />

    <!-- remove duplicates from AllEnvironmentsToRelease -->
    <Message Text="AllEnvironmentsToRelease: @(AllEnvironmentsToRelease)" />

        <MSBuild.ExtensionPack.Framework.MsBuildHelper TaskAction="RemoveDuplicateFiles" InputItems1="@(AllEnvironmentsToRelease)" Condition=" @(AllEnvironmentsToRelease) != '' ">
            <Output TaskParameter="OutputItems" ItemName="AllEnvironmentsToReleaseCleaned"/>
        </MSBuild.ExtensionPack.Framework.MsBuildHelper>

    <Message Text="AllEnvironmentsToReleaseCleaned: @(AllEnvironmentsToReleaseCleaned)" />

    <ItemGroup>
      <_ItemsToCopyToReleaseItemGroup Remove="@(_ItemsToCopyToReleaseItemGroup)" />
      <_ItemsToCopyToReleaseItemGroup Include="@(_ItemsToCopyToReleaseItemGroup)">
        <Environment>%(AllEnvironmentsToReleaseCleaned.Identity)</Environment>
      </_ItemsToCopyToReleaseItemGroup>
	  
      <ItemsToCopyToReleaseItemGroup Remove="@(ItemsToCopyToReleaseItemGroup)" />
      <ItemsToCopyToReleaseItemGroup Include="%(_ItemsToCopyToReleaseItemGroup.Identity)">
        <Destination>$([System.String]::Copy('%(_ItemsToCopyToReleaseItemGroup.Identity)').Replace("c:",""))</Destination>
      </ItemsToCopyToReleaseItemGroup>
    </ItemGroup>
	
    <Message Text="ItemsToCopyToReleaseItemGroup: @(ItemsToCopyToReleaseItemGroup)" />

    <!-- copy deployment scripts to each environment directory -->
    <Copy SourceFiles="@(ItemsToCopyToReleaseItemGroup)" DestinationFiles="$(ReleaseDirectory)%(ItemsToCopyToReleaseItemGroup.Environment)\needed-for\correct-directory-depth\%(ItemsToCopyToReleaseItemGroup.Destination)" />

    <Message Text="ReleaseDirectoriesToRemove: @(ReleaseDirectoriesToRemove)" />

    <!-- remove all release dirs, leaving just the zip files -->
    <MSBuild.ExtensionPack.FileSystem.Folder TaskAction="RemoveContent" Path="%(ReleaseDirectoriesToRemove.FullPath)" Condition=" Exists('%(ReleaseDirectoriesToRemove.FullPath)') " />
    <RemoveDir Directories="@(ReleaseDirectoriesToRemove)" Condition=" @(ReleaseDirectoriesToRemove) != '' " />

  </Target>	

  <!-- endregion Release targets -->

  <!-- beginregion Deploy targets -->

  <Target Name="DeployWebsite">
    <ItemGroup>
      <_MSDeployProjectsToDeploy Include="$(ReleaseDirectory)\$(DeployEnvironment)\**\*$(WebsiteProjectConventionName)*.zip" />		
      <_MSDeployProjectsToDeploy Include="$(BaseDirectory)\**\*$(WebsiteProjectConventionName)*.zip" Condition=" !Exists('$(ReleaseDirectory)') " />		
    </ItemGroup>		
  </Target>

  <Target Name="DeployWebService">
    <ItemGroup>
      <_MSDeployProjectsToDeploy Include="$(ReleaseDirectory)\$(DeployEnvironment)\**\*$(WebServiceProjectConventionName)*.zip" />		
      <_MSDeployProjectsToDeploy Include="$(BaseDirectory)\**\*$(WebServiceProjectConventionName)*.zip" Condition=" !Exists('$(ReleaseDirectory)') " />		
    </ItemGroup>		
  </Target>

  <Target Name="DeployStaticHtml">
    <ItemGroup>		
      <_MSDeployProjectsToDeploy Include="$(ReleaseDirectory)\$(DeployEnvironment)\**\*$(StaticHtmlProjectConventionName)*.zip" />		
      <_MSDeployProjectsToDeploy Include="$(BaseDirectory)\**\*$(StaticHtmlProjectConventionName)*.zip" Condition=" !Exists('$(ReleaseDirectory)') " />		
    </ItemGroup>
  </Target>

  <Target Name="DeployWebsiteAndWebServiceAndStaticHtml" DependsOnTargets="DeployWebsite;DeployWebService;DeployStaticHtml">
    <ItemGroup>
      <MSDeployProjectsToDeploy Include="%(_MSDeployProjectsToDeploy.FullPath)" Condition=" $([System.String]::Copy('%(_MSDeployProjectsToDeploy.Filename)').Contains($(ProjectToDeploy))) And $([System.String]::Copy('%(_MSDeployProjectsToDeploy.Filename)').Contains($(BuildVersion))) " />
    </ItemGroup>

    <Warning Text="There are no more projects to deploy after filtering on BuildVersion: $(BuildVersion)" Condition=" '@(_MSDeployProjectsToDeploy->Count())' &gt; 0 AND '@(MSDeployProjectsToDeploy->Count())' == 0 " />
    <Warning Text="Project before filtering: @(_MSDeployProjectsToDeploy)" Condition=" '@(_MSDeployProjectsToDeploy->Count())' &gt; 0 AND '@(MSDeployProjectsToDeploy->Count())' == 0 " />
  </Target>

  <Target Name="CoreMsDeployDeploy" Inputs="%(MSDeployProjectsToDeploy.RootDir)%(MSDeployProjectsToDeploy.Directory)" Outputs="AlwaysExecute">

    <!-- call targets 'Deploy' with parameters '/p:DeployEnvironment=<environment to deploy to>;ProjectToDeploy=<project filename without extension>;DeployServer=<server - with msdeploy installed - to deploy to>;DeployTargetName=<iis sitename to update>;DeployUsername=<msdeploy user>;DeployPassword=<msdeploy password>' -->
    <Error Condition = " '$(DeployEnvironment)' == '' And Exists('$(ReleaseDirectory)') " Text="Please set parameter DeployEnvironment to select the proper artifacts to deploy." />

    <!-- unzip file first -->
    <Unzip ZipFileName="%(MSDeployProjectsToDeploy.FullPath)" TargetDirectory="%(MSDeployProjectsToDeploy.RootDir)%(MSDeployProjectsToDeploy.Directory)$(ProjectToDeploy)" />

    <PropertyGroup>
      <MSDeploySkipDirectoryParameter Condition=" $(DeploySkipDirectoryPattern) != '' ">-skip:objectName=dirPath,absolutePath=&quot;$(DeploySkipDirectoryPattern)&quot;</MSDeploySkipDirectoryParameter>
      <MSDeploySkipFileParameter Condition=" $(DeploySkipFilePattern) != '' ">-skip:objectName=filePath,absolutePath=&quot;$(DeploySkipFilePattern)&quot;</MSDeploySkipFileParameter>
      <ProjectReleaseDirectory>%(MSDeployProjectsToDeploy.RootDir)%(MSDeployProjectsToDeploy.Directory)$(ProjectToDeploy)</ProjectReleaseDirectory>
      <OptionalArgument Condition="$(EnableDoNotDeleteRule) == 'true'">-enableRule:DoNotDeleteRule</OptionalArgument>
    </PropertyGroup>

    <Message Importance="high" Text="Using 'normal' Msdeploy option [wmsvc[" Condition="$(UseMsDepoyAzureTask) == 'False'" />
    <Message Importance="high" Text="Using azure msdeploy option [Computername]" Condition="$(UseMsDepoyAzureTask) == 'True'" />

    <!--Azure deploy does not use port 8192, therefore wmsvc cannot be used. Use Computername instead.-->
    <Exec Condition="$(UseMsDepoyAzureTask) == 'True'"
          Command="&quot;$(MsDeployPath)&quot; -verb:sync -source:contentpath=&quot;$(ProjectReleaseDirectory)&quot; -dest:contentpath=&quot;$(DeployTargetName)&quot;,Computername=&quot;$(DeployServer)/msdeploy.axd?site=$(DeployTargetName)&quot;,username=&quot;$(DeployUsername)&quot;,password=&quot;$(DeployPassword)&quot;,AuthType=&quot;Basic&quot; $(MSDeploySkipDirectoryParameter) $(MSDeploySkipFileParameter)"
           />
    
    <Exec Condition="$(UseMsDepoyAzureTask) == 'False'" 
          Command="&quot;$(MsDeployPath)&quot; -verb:sync -source:contentpath=&quot;$(ProjectReleaseDirectory)&quot; -dest:contentpath=&quot;$(DeployTargetName)&quot;,wmsvc=$(DeployServer),username=$(DeployUsername),password=$(DeployPassword) -allowUntrusted $(MSDeploySkipDirectoryParameter) $(MSDeploySkipFileParameter) $(OptionalArgument)"
           />

    <RemoveDir Directories="$(ProjectReleaseDirectory)" />

    <HttpRequest Url="$(DeployWarmupUrl)" FailOnNon2xxResponse="true" Condition=" $(DeployWarmupUrl) != '' " />

  </Target>

  <Target Name="DeployConsoleApp" DependsOnTargets="BeforeDeployConsoleApp;CoreDeployConsoleApp" />
  <Target Name="BeforeDeployConsoleApp">
    <ItemGroup>
      <_ConsoleAppsToDeploy Include="$(ReleaseDirectory)\$(DeployEnvironment)\**\*$(ConsoleAppProjectConventionName)*.zip" />	
      <_ConsoleAppsToDeploy Include="$(BaseDirectory)**\*$(ConsoleAppProjectConventionName)*.zip" Condition=" !Exists('$(ReleaseDirectory)') " />			
      <ConsoleAppsToDeploy Include="%(_ConsoleAppsToDeploy.FullPath)" Condition=" $([System.String]::Copy('%(_ConsoleAppsToDeploy.Filename)').Contains($(ProjectToDeploy))) And $([System.String]::Copy('%(_ConsoleAppsToDeploy.Filename)').Contains($(BuildVersion))) " />
    </ItemGroup>
  </Target>
  <Target Name="CoreDeployConsoleApp" Inputs="%(ConsoleAppsToDeploy.RootDir)%(ConsoleAppsToDeploy.Directory)" Outputs="NonExistingOutputToTriggerTargetForEveryProject">

    <!-- todo deploy with msdeploy or robocopy -->

  </Target>

  <Target Name="DeployService" DependsOnTargets="BeforeDeployService;CoreDeployService" />
  <Target Name="BeforeDeployService">
    <ItemGroup>			
      <_ServicesToDeploy Include="$(ReleaseDirectory)\$(DeployEnvironment)\**\*$(WindowsServiceProjectConventionName)*.zip" />
      <_ServicesToDeploy Include="$(BaseDirectory)**\*$(WindowsServiceProjectConventionName)*.zip" Condition=" !Exists('$(ReleaseDirectory)') " />						
      <ServicesToDeploy Include="%(_ServicesToDeploy.FullPath)" Condition=" $([System.String]::Copy('%(_ServicesToDeploy.Filename)').Contains($(ProjectToDeploy))) And $([System.String]::Copy('%(_ServicesToDeploy.Filename)').Contains($(BuildVersion))) " />
    </ItemGroup>
  </Target>
  <Target Name="CoreDeployService" Inputs="%(ServicesToDeploy.RootDir)%(ServicesToDeploy.Directory)" Outputs="NonExistingOutputToTriggerTargetForEveryProject">

    <!-- call targets 'Deploy' with parameters '/p:DeployEnvironment=<environment to deploy to>;ProjectToDeploy=<project filename without extension>;DeployServer=<server to deploy to>;DeployDirectory=<path of the service directory within DeployServer>' -->
    <Error Condition = " '$(DeployEnvironment)' == '' " Text="Please set parameter DeployEnvironment to select the proper artifacts to deploy." />

    <!-- unzip file first -->
    <Unzip ZipFileName="%(ServicesToDeploy.FullPath)" TargetDirectory="%(ServicesToDeploy.RootDir)%(ServicesToDeploy.Directory)$(ProjectToDeploy)" />

    <PropertyGroup>
      <ServiceName>$(ProjectToDeploy).$(DeployEnvironment)</ServiceName>
      <ProjectReleaseDirectory>%(ServicesToDeploy.RootDir)%(ServicesToDeploy.Directory)$(ProjectToDeploy)</ProjectReleaseDirectory>

      <ServerExist>False</ServerExist>
      <ServiceExist>False</ServiceExist>
    </PropertyGroup>		

    <Message Text="DeployServer: [$(DeployServer)]" />
    <Message Text="DeployUserDomain: [$(DeployUserDomain)]" />
    <Message Text="DeployUsername: [$(DeployUsername)]" />
    <Message Text="DeployPassword: [$(DeployPassword)]" />

    <!-- Ping the server -->
    <MSBuild.ExtensionPack.Computer.Network TaskAction="Ping" HostName="$(DeployServer)">
      <Output TaskParameter="Exists" PropertyName="ServerExist"/>
    </MSBuild.ExtensionPack.Computer.Network>
    <Message Text="$(DeployServer) is pingable: $(ServerExist)"/>

    <!-- Check whether the service exists -->
    <Message Text="RemoteUser: [$(DeployUserDomain)\$(DeployUsername)]" />
    <MSBuild.ExtensionPack.Computer.WindowsService TaskAction="CheckExists" ServiceName="$(ServiceName)" MachineName="$(DeployServer)" RemoteUser="$(DeployUserDomain)\$(DeployUsername)" RemoteUserPassword="$(DeployPassword)" Condition=" '$(ServerExist)' == 'True'">
      <Output TaskParameter="Exists" PropertyName="ServiceExist"/>
    </MSBuild.ExtensionPack.Computer.WindowsService>
    <Message Text="Service: $(ServiceName) exist on: $(DeployServer)." Condition=" '$(ServiceExist)' == 'True'" /> 

    <!-- Stop the service before updating --> 
        <MSBuild.ExtensionPack.Computer.WindowsService TaskAction="Stop" ServiceName="$(ServiceName)" MachineName="$(DeployServer)" RemoteUser="$(DeployUserDomain)\$(DeployUsername)" RemoteUserPassword="$(DeployPassword)" Condition=" '$(ServiceExist)' == 'True'" />

    <!-- Authentication on the server -->
    <Exec Command="NET USE \\$(DeployServer) /delete" IgnoreExitCode="true" />
    <Exec Command="NET USE \\$(DeployServer) /user:$(DeployUserDomain)\$(DeployUsername) $(DeployPassword)" />

    <!-- Update the service --> 
        <MSBuild.ExtensionPack.FileSystem.RoboCopy Source="$(ProjectReleaseDirectory)" Destination="\\$(DeployServer)\$([System.String]::Copy('$(DeployDirectory)').Replace(':', '$'))" Files="*.*" Options="/MIR">
            <Output TaskParameter="ExitCode" PropertyName="Exit" />
            <!--Output TaskParameter="ReturnCode" PropertyName="Return" /-->
        </MSBuild.ExtensionPack.FileSystem.RoboCopy>
    <Error Condition = " '$(Exit)' != '0' " Text="MSBuild.ExtensionPack.FileSystem.RoboCopy (RoboCopy.exe) failed. Examine the log." />

    <!-- If the service did not exists, install it -->
    <Message Text="ServiceUsername: [$(ServiceUsername)]" Condition=" '$(ServiceExist)' == 'False'" />
    <Message Text="ServicePassword: [$(ServicePassword)]" Condition=" '$(ServiceExist)' == 'False'" />
    <MSBuild.ExtensionPack.Computer.WindowsService TaskAction="Install" ServiceName="$(ServiceName)" ServicePath="$(DeployDirectory)\$(ProjectToDeploy).exe" User="$(ServiceUsername)" Password="$(ServicePassword)" StartupType="Automatic" ServiceDisplayName="$(ProjectToDeploy)" MachineName="$(DeployServer)" RemoteUser="$(DeployUserDomain)\$(DeployUsername)" RemoteUserPassword="$(DeployPassword)" Condition=" '$(ServiceExist)' == 'False'" />
        
    <!-- Start the service --> 
    <MSBuild.ExtensionPack.Computer.WindowsService TaskAction="Start" ServiceName="$(ServiceName)" MachineName="$(DeployServer)" RemoteUser="$(DeployUserDomain)\$(DeployUsername)" RemoteUserPassword="$(DeployPassword)"  /> 

  </Target>	

  <Target Name="DeployDatabase" DependsOnTargets="BeforeDeployDatabase;CoreDeployDatabase" />
  <Target Name="BeforeDeployDatabase">
    <ItemGroup>
      <_DatabasesToDeploy Include="$(ReleaseDirectory)\$(DeployEnvironment)\**\*$(DatabaseProjectConventionName)*.zip" />
      <_DatabasesToDeploy Include="$(BaseDirectory)**\*$(DatabaseProjectConventionName)*.zip" Condition=" !Exists('$(ReleaseDirectory)') " />						
      <DatabasesToDeploy Include="%(_DatabasesToDeploy.FullPath)" Condition=" $([System.String]::Copy('%(_DatabasesToDeploy.Filename)').Contains($(ProjectToDeploy))) And $([System.String]::Copy('%(_DatabasesToDeploy.Filename)').Contains($(BuildVersion))) " />					
    </ItemGroup>
  </Target>
  <Target Name="CoreDeployDatabase" Inputs="%(DatabasesToDeploy.RootDir)%(DatabasesToDeploy.Directory)" Outputs="NonExistingOutputToTriggerTargetForEveryProject">
    <!-- call targets 'Deploy' with parameters '/p:ProjectToDeploy=<database project filename without extension>;DeployServer=<database-server to deploy to>;DeployTargetName=<database name on the server to update>;DeployUsername=<msdeploy user>;DeployPassword=<msdeploy password>' -->

    <!-- unzip file first -->
    <Unzip ZipFileName="%(DatabasesToDeploy.FullPath)" TargetDirectory="%(DatabasesToDeploy.RootDir)%(DatabasesToDeploy.Directory)$(ProjectToDeploy)" />						

    <PropertyGroup>
      <DatabasesToDeployPath>%(DatabasesToDeploy.RootDir)%(DatabasesToDeploy.Directory)$(ProjectToDeploy)\</DatabasesToDeployPath>
      <ConnectionConfigFile>$(DatabasesToDeployPath)connection.config</ConnectionConfigFile>
    </PropertyGroup>

    <!-- deploy database via mirabeau database release tool -->
    <Exec WorkingDirectory="$(DatabasesToDeployPath)" Command="Mirabeau.DatabaseReleaseTool.exe -d:. -c:$(ConnectionConfigFile) -databasetype:$(DeployDatabaseType) -vf:1.0.0 -vt:$(BuildVersion)" Condition=" Exists('$(ConnectionConfigFile)') " />

    <PropertyGroup>
      <DacPacPath>%(DatabasesToDeploy.RootDir)%(DatabasesToDeploy.Directory)$(ProjectToDeploy)\$(ProjectToDeploy).dacpac</DacPacPath>
    </PropertyGroup>

    <!-- deploy data-tier application project (http://msdn.microsoft.com/en-us/library/hh550080(v=vs.103).aspx) -->
    <Exec WorkingDirectory="$(MSBuildProjectDirectory)" Command="&quot;$(SqlServerRedistPath)\SqlPackage.exe&quot; /Action:Publish /SourceFile:&quot;$(DacPacPath)&quot; /TargetServerName:&quot;$(DeployServer)&quot; /TargetPassword:&quot;$(DeployPassword)&quot; /TargetUser:&quot;$(DeployUsername)&quot; /TargetDatabaseName:&quot;$(DeployTargetName)&quot; /p:AllowIncompatiblePlatform=$(DacDeployAllowIncompatiblePlatform) /p:GenerateSmartDefaults=$(DacDeployGenerateSmartDefaults) /p:BlockOnPossibleDataLoss=$(DacDeployBlockOnPossibleDataLoss)" Condition=" Exists('$(DacPacPath)') " />

  </Target>

  <Target Name="DeployAzure" DependsOnTargets="BeforeDeployAzure;CoreDeployAzure" />
  <Target Name="BeforeDeployAzure">
    <ItemGroup>
      <_AzureToDeploy Include="$(ReleaseDirectory)\$(DeployEnvironment)\**\*$(AzureProjectConventionName)*.zip" />
      <_AzureToDeploy Include="$(BaseDirectory)**\*$(AzureProjectConventionName)*.zip" Condition=" !Exists('$(ReleaseDirectory)') " />			
      <AzureToDeploy Include="%(_AzureToDeploy.FullPath)" Condition=" $([System.String]::Copy('%(_AzureToDeploy.Filename)').Contains($(ProjectToDeploy))) And $([System.String]::Copy('%(_AzureToDeploy.Filename)').Contains($(BuildVersion))) " />
    </ItemGroup>
  </Target>
  <Target Name="CoreDeployAzure" Inputs="%(AzureToDeploy.RootDir)%(AzureToDeploy.Directory)" Outputs="NonExistingOutputToTriggerTargetForEveryProject">
    <!-- call targets 'Deploy' with parameters '/p:DeployEnvironment=<environment to deploy to>;ProjectToDeploy=<azure project filename without extension>;AzureSubscriptionID=<AzureSubscriptionID>;AzureCertificateFilename=<AzureCertificateFilename>;AzureCertificatePassword=<AzureCertificatePassword>;AzureHostedServiceName=<AzureHostedServiceName>;AzureStorageAccountName=<AzureStorageAccountName>;AzureStorageAccountKey=<AzureStorageAccountKey>;AzureSwapToProductionAfterDeploy=(True|False);AzureRemoveStagingAfterSwap=(True|False);AzureUpgradeInPlace=(True|False)' -->

    <Error Condition = " '$(DeployEnvironment)' == '' And Exists('$(ReleaseDirectory)') " Text="Please set parameter DeployEnvironment to select the proper artifacts to deploy." />

    <!-- unzip file first -->
    <Unzip ZipFileName="%(AzureToDeploy.FullPath)" TargetDirectory="%(AzureToDeploy.RootDir)%(AzureToDeploy.Directory)$(ProjectToDeploy)" />			

    <PropertyGroup>
      <ProjectReleaseDirectory>%(AzureToDeploy.RootDir)%(AzureToDeploy.Directory)$(ProjectToDeploy)</ProjectReleaseDirectory>
    </PropertyGroup>

    <Error Condition = " !Exists('$(ProjectReleaseDirectory)') " Text="The artifacts at location $(ProjectReleaseDirectory) do not exist. Check if you performed a full release or you project has a config transform for this specific environment." />	

    <PropertyGroup>
      <PackageLocation>$(ProjectReleaseDirectory)</PackageLocation>
      <PackageName>$(ProjectToDeploy).cspkg</PackageName>
      <ServiceConfigName>ServiceConfiguration.cscfg</ServiceConfigName>
    </PropertyGroup>

    <!-- https://www.windowsazure.com/en-us/develop/net/common-tasks/continuous-delivery/ -->
    <Exec WorkingDirectory="$(MSBuildProjectDirectory)" Command="$(PowershellPath) -f $(AzureDeployScript) -serviceName $(AzureHostedServiceName) -storageAccountName $(AzureStorageAccountName) -packageLocation $(PackageLocation)\$(PackageName) -cloudConfigLocation $(PackageLocation)\$(ServiceConfigName) -deploymentLabel $(BuildVersion) -certificateFilename $(AzureCertificateFilename) -certificatePassword $(AzureCertificatePassword) -subscriptionid $(AzureSubscriptionID) -swapAfterDeploy $(AzureSwapToProductionAfterDeploy) -deleteStagingAfterSwap $(AzureRemoveStagingAfterSwap) enableDeploymentUpgrade $(AzureUpgradeInPlace)" />	

  </Target>

  <Target Name="DeployNugetPackages" DependsOnTargets="BeforeDeployNugetPackage;CoreDeployNugetPackage" />
  <Target Name="BeforeDeployNugetPackage">
    <ItemGroup>
      <NuGetToDeploy Include="$(ReleaseDirectory)$(NuGetDirectoryName)\$(ProjectToDeploy).$(BuildVersion).nupkg" Condition=" Exists('$(ReleaseDirectory)$(NuGetDirectoryName)\$(ProjectToDeploy).$(BuildVersion).nupkg') " />
      <NuGetToDeploy Include="$(BaseDirectory)$(ProjectToDeploy).$(BuildVersion).nupkg" Condition=" !Exists('$(ReleaseDirectory)') And Exists('$(BaseDirectory)$(ProjectToDeploy).$(BuildVersion).nupkg') " />			
    </ItemGroup>	

    <Message Text="NuGetToDeploy: @(NuGetToDeploy)" />
  </Target>
  <Target Name="CoreDeployNugetPackage" Inputs="%(NuGetToDeploy.RootDir)%(NuGetToDeploy.Directory)%(NuGetToDeploy.Filename)" Outputs="AlwaysExecute">

    <Error Text="Please provide and api key with parameter NuGetApiKey." Condition=" $(NuGetApiKey) == '' " />

    <PropertyGroup>
      <SourceParameter Condition=" '$(NuGetServerUrl)' != '' ">-s $(NuGetServerUrl)</SourceParameter>
    </PropertyGroup>

    <!-- create the package -->
    <Exec Command="&quot;$(NuGetPath)&quot; push &quot;%(NuGetToDeploy.RelativeDir)%(NuGetToDeploy.Filename)%(NuGetToDeploy.Extension)&quot; $(NuGetApiKey) -ConfigFile &quot;$(NuGetConfigPath)&quot; $(SourceParameter)" />

  </Target>	

  <Target Name="AfterDeploy">

    <ItemGroup>
      <AllProjectsToDeploy Remove="@(AllProjectsToDeploy)" />
      <AllProjectsToDeploy Include="@(MSDeployProjectsToDeploy)" />
      <AllProjectsToDeploy Include="@(ConsoleAppsToDeploy)" />
      <AllProjectsToDeploy Include="@(ServicesToDeploy)" />
      <AllProjectsToDeploy Include="@(DatabasesToDeploy)" />
      <AllProjectsToDeploy Include="@(AzureToDeploy)" />
      <AllProjectsToDeploy Include="@(NuGetToDeploy)" />
    </ItemGroup>

    <!-- throw an error if there was nothing to deploy -->
    <Error Text="There are no projects to be deployed!" Condition=" @(AllProjectsToDeploy) == '' " />

  </Target>

  <!-- endregion Deploy targets -->


  <!-- beginregion Delete targets -->	

  <Target Name="DeleteAzure" DependsOnTargets="BeforeDeleteAzure;CoreDeleteAzure" />
  <Target Name="BeforeDeleteAzure">
    <ItemGroup>
      <_AzureToDelete Include="$(SourceDirectory)**\*.$(AzureProjectConventionName).ccproj" />
      <AzureToDelete Include="@(_AzureToDelete)" Condition = " %(_AzureToDelete.Filename) == $(ProjectToDelete) " />
    </ItemGroup>
  </Target>
  <Target Name="CoreDeleteAzure" Inputs="%(AzureToDelete.RootDir)%(AzureToDelete.Directory)" Outputs="AlwaysExecute">
    <!-- call targets 'Delete' with parameters 'ProjectToDelete=<azure project filename without extension>;AzureSubscriptionID=<AzureSubscriptionID>;AzureCertificateFilename=<AzureCertificateFilename>;AzureCertificatePassword=<AzureCertificatePassword>;AzureHostedServiceName=<AzureHostedServiceName>;AzureHostedServiceSlot=<Staging|Production>' -->

    <!-- https://www.windowsazure.com/en-us/develop/net/common-tasks/continuous-delivery/ -->
    <Exec WorkingDirectory="$(MSBuildProjectDirectory)" Command="$(PowershellPath) -f $(AzureDeleteScript) -serviceName $(AzureHostedServiceName) -certificateFilename $(AzureCertificateFilename) -certificatePassword $(AzureCertificatePassword) -subscriptionid $(AzureSubscriptionID) -swapAfterDeploy $(AzureSwapToProductionAfterDeploy) -hostedServiceSlot $(AzureHostedServiceSlot)" />	

  </Target>

  <Target Name="DeleteDatabase" DependsOnTargets="BeforeDeleteDatabase;CoreDeleteDatabase" />
  <Target Name="BeforeDeleteDatabase">
    <ItemGroup>
      <_DatabaseToDelete Include="$(SourceDirectory)**\*.$(DatabaseProjectConventionName).sqlproj" />
      <DatabaseToDelete Include="@(_DatabaseToDelete)" Condition = " %(_DatabaseToDelete.Filename) == $(ProjectToDelete) " />
    </ItemGroup>
  </Target>
  <Target Name="CoreDeleteDatabase" Inputs="%(DatabaseToDelete.RootDir)%(DatabaseToDelete.Directory)" Outputs="AlwaysExecute">
    <!-- call targets 'Delete' with parameters 'ProjectToDelete=<database project filename without extension>;AzureSubscriptionID=<AzureSubscriptionID>;AzureCertificateFilename=<AzureCertificateFilename>;AzureCertificatePassword=<AzureCertificatePassword>;DeployServer=<DeployServer>;DeployTargetName=<DeployTargetName>;DeployUsername=<DeployUsername>;DeployPassword=<DeployPassword>' -->
    
    <!-- https://www.windowsazure.com/en-us/develop/net/common-tasks/continuous-delivery/ -->
    <Exec WorkingDirectory="$(MSBuildProjectDirectory)" Command="$(PowershellPath) -f $(AzureDatabaseDeleteScript) -serverName $(DeployServer) -databaseName $(DeployTargetName) -certificateFilename $(AzureCertificateFilename) -certificatePassword $(AzureCertificatePassword) -subscriptionid $(AzureSubscriptionID) -username $(DeployUsername) -password $(DeployPassword)" />	
    
  </Target>

  <Target Name="AfterDelete">

    <ItemGroup>
      <AllProjectsToDelete Remove="@(AllProjectsToDelete)" />
      <AllProjectsToDelete Include="@(AzureToDelete)" />
      <AllProjectsToDelete Include="@(DatabaseToDelete)" />
    </ItemGroup>

    <PropertyGroup>
      <OneOrMoreProjectsDeleted>False</OneOrMoreProjectsDeleted>
      <OneOrMoreProjectsDeleted Condition=" %(AllProjectsToDelete.Filename) == $(ProjectToDelete) ">True</OneOrMoreProjectsDeleted>
    </PropertyGroup>

    <!-- throw an error if there was nothing to delete -->
    <Error Text="There are no projects to be deleted!" Condition=" $(OneOrMoreProjectsDeleted) == False " />

  </Target>

  <!-- endregion Delete targets -->	

   <!-- beginregion Miscellaneous targets -->
   
  <Target Name="SwapAzure">
    <!-- call targets 'SwapAzure' with parameters 'AzureSubscriptionID=<AzureSubscriptionID>;AzureCertificateFilename=<AzureCertificateFilename>;AzureCertificatePassword=<AzureCertificatePassword>;AzureHostedServiceName=<AzureHostedServiceName>;AzureHostedServiceSlot=<Staging|Production>' -->
    
    <!-- https://www.windowsazure.com/en-us/develop/net/common-tasks/continuous-delivery/ -->
    <Exec WorkingDirectory="$(MSBuildProjectDirectory)" Command="$(PowershellPath) -f $(AzureSwapScript) -serviceName $(AzureHostedServiceName) -certificateFilename $(AzureCertificateFilename) -certificatePassword $(AzureCertificatePassword) -subscriptionid $(AzureSubscriptionID) -swapAfterDeploy $(AzureSwapToProductionAfterDeploy) -hostedServiceSlot $(AzureHostedServiceSlot)" />	
    
  </Target>   
   
   <!-- endregion Miscellaneous targets -->   
  
  <!-- beginregion Analyze targets -->	

  <Target Name="AnalyzeWithFxCop" DependsOnTargets="Build">

    <!-- Include all assemblies that are generated from our own projects -->
    <ItemGroup>
      <ProjectsToAnalyze Include="$(SourceDirectory)**\*.csproj" />
    </ItemGroup>
    <ItemGroup>
      <AssembliesToAnalyze Include="%(ProjectsToAnalyze.RootDir)%(ProjectsToAnalyze.Directory)bin\$(Configuration)\%(ProjectsToAnalyze.Filename).dll" Condition=" Exists('%(ProjectsToAnalyze.RootDir)%(ProjectsToAnalyze.Directory)bin\$(Configuration)\%(ProjectsToAnalyze.Filename).dll') " />
      <AssembliesToAnalyze Include="%(ProjectsToAnalyze.RootDir)%(ProjectsToAnalyze.Directory)bin\%(ProjectsToAnalyze.Filename).dll" Condition=" Exists('%(ProjectsToAnalyze.RootDir)%(ProjectsToAnalyze.Directory)bin\%(ProjectsToAnalyze.Filename).dll') " />
    </ItemGroup>

    <!-- Run fxcop for AssembliesToAnalyze -->
    <MSBuild.ExtensionPack.CodeQuality.FxCop TaskAction="Analyse" Files="@(AssembliesToAnalyze)" OutputFile="$(CodeAnalysisDirectory)FxCopReport.html" Rules="$(FxCopPath)Rules" FxCopPath="$(FxCopPath)FxCopCmd.exe" ShowSummary="true" LogToConsole="false" ReportXsl="$(FxCopPath)Xml\FxCopReport.xsl" DependencyDirectories="$(BinDirectory)" Condition=" $(SkipAnalysis) == 'False' " />

  </Target>

  <Target Name="AnalyzeWithSonar" DependsOnTargets="BeforeAnalyzeWithSonar;CoreAnalyseWithSonarCSharp;CoreAnalyseWithSonarJavascript">
  </Target>
  
  <Target Name="BeforeAnalyzeWithSonar" DependsOnTargets="PrepareGlobalProperties;CompileCheck">

    <ItemGroup>		
      <_SolutionsToAnalyze Include="$(CSharpSourceDirectory)**\*.sln" />
      <SolutionsToAnalyze Include="%(_SolutionsToAnalyze.RelativeDir)%(_SolutionsToAnalyze.Filename)%(_SolutionsToAnalyze.Extension)"/>
      <_JavascriptWebProjectsToAnalyse Include="$(CSharpSourceDirectory)**\*.$(WebsiteProjectConventionName).csproj"/>
      <JavascriptWebProjectsToAnalyse Include="%(_JavascriptWebProjectsToAnalyse.RelativeDir)%(_JavascriptWebProjectsToAnalyse.Filename)%(_JavascriptWebProjectsToAnalyse.Extension)"/>
      <AssembliesToExludeFromCoverage Include="$(CSharpSourceDirectory)**\*.$(IntegrationTestsProjectConventionName).csproj;$(CSharpSourceDirectory)**\*.$(UnitTestsProjectConventionName).csproj" />					     
    </ItemGroup>
    <PropertyGroup>
      <ExcludeFromCoverage>@(AssembliesToExludeFromCoverage -> '%(Filename)', ',')</ExcludeFromCoverage>
      
      <SonarJavascriptAnalysis Condition=" %(JavascriptWebProjectsToAnalyse.Filename) != '' and $(SonarJavascriptAnalysis) == ''">True</SonarJavascriptAnalysis>
      <SonarConnectionParameters>-D sonar.host.url=&quot;$(SonarHostUrl)&quot; -D sonar.jdbc.url=&quot;$(SonarDbConnectionString)&quot; -D sonar.jdbc.username=&quot;$(SonarDbUsername)&quot; -D sonar.jdbc.password=&quot;$(SonarDbPassword)&quot; -D sonar.sourceEncoding=UTF-8 -D SONAR_RUNNER_OPTS=$(SonarRunnerOpts)</SonarConnectionParameters>
      <SonarConnectionParameters Condition=" $(SonarProfile) != '' ">$(SonarConnectionParameters) -D sonar.profile=&quot;$(SonarProfile)&quot;</SonarConnectionParameters>
	  <SonarSource>$(AbsoluteSourceDirectory.Replace('\', '/'))</SonarSource>
      <OptionalDebugArgument Condition="$(SonarDebugMode) == 'true'">-X</OptionalDebugArgument>
    </PropertyGroup>
    
  </Target>
  <Target Name="CoreAnalyseWithSonarJavascript" Inputs="%(JavascriptWebProjectsToAnalyse.RelativeDir)%(JavascriptWebProjectsToAnalyse.Filename)%(JavascriptWebProjectsToAnalyse.Extension)" Outputs="NonExistingOutputToTriggerTargetForEveryWebproject">	
  <PropertyGroup>
      <ProjectName>$(SonarProjectName)</ProjectName>
      <ProjectName Condition=" '$(SonarProjectName)' == '' ">%(JavascriptWebProjectsToAnalyse.Filename)</ProjectName>
      <ProjectName>$(SonarProjectPrefix)$(ProjectName)</ProjectName>
      <ProjectKey>$(SonarProjectKey)</ProjectKey>			
      <ProjectKey Condition=" '$(SonarProjectKey)' == '' ">%(JavascriptWebProjectsToAnalyse.Filename)</ProjectKey>											       
      <ProjectKey>$(SonarProjectPrefix)$(ProjectKey)</ProjectKey>
  </PropertyGroup>
  
      <!--javascipt analysis requires the project home to be set to the root and specify the source path from the root.-->
    <Exec Command="&quot;$(SonarRunnerPath)&quot; $(OptionalDebugArgument) -D sonar.projectKey=$(ProjectKey)-JS -D sonar.projectName=&quot;$(ProjectName)-JS&quot; -D sonar.projectVersion=$(BuildVersion) $(SonarConnectionParameters) -D sonar.exclusions=&quot;$(SonarGlobalJavascriptExcludePattern),$(SonarProjectJavascriptExcludePattern)&quot; -D sonar.sources=&quot;$(SonarSourceFolder)&quot; -D project.home=&quot;$(SonarBaseDirectory)&quot; -D sonar.language=js -D sonar.gallio.installDirectory=$(GallioPath) -D sonar.gallio.coverage.tool=OpenCover -D sonar.opencover.installDirectory=$(OpenCoverPath) -D sonar.dotnet.visualstudio.testProjectPattern=*$(UnitTestsProjectConventionName)*; -D sonar.gallio.coverage.excludes=&quot;$(ExcludeFromCoverage)&quot;" Condition=" $(SkipAnalysis) == 'False' And '$(SonarJavascriptAnalysis)' == 'True'" IgnoreExitCode="true" />
  </Target>
  
  <Target Name="CoreAnalyseWithSonarCSharp" Inputs="%(SolutionsToAnalyze.RelativeDir)%(SolutionsToAnalyze.Filename)%(SolutionsToAnalyze.Extension)" Outputs="NonExistingOutputToTriggerTargetForEverySolution">		
  
  <ConvertToAbsolutePath Paths="%(SolutionsToAnalyze.RelativeDir)">
    <Output TaskParameter="AbsolutePaths" PropertyName="AbsoluteSolutionsToAnalyzeDirectory" />
  </ConvertToAbsolutePath>
    
  <PropertyGroup>
      <ProjectName>$(SonarProjectName)</ProjectName>
      <ProjectName Condition=" '$(SonarProjectName)' == '' ">%(SolutionsToAnalyze.Filename)</ProjectName>
      <ProjectName>$(SonarProjectPrefix)$(ProjectName)</ProjectName>
      <ProjectKey>$(SonarProjectKey)</ProjectKey>
      <ProjectKey Condition=" '$(SonarProjectKey)' == '' ">%(SolutionsToAnalyze.Filename)</ProjectKey>
      <ProjectKey>$(SonarProjectPrefix)$(ProjectKey)</ProjectKey>
      <SonarAbsoluteSolutionsToAnalyzeDirectory>$(AbsoluteSolutionsToAnalyzeDirectory.Replace('\', '/'))</SonarAbsoluteSolutionsToAnalyzeDirectory>
  </PropertyGroup>

    <!--Run cs and js. Cannot be done in one run yet: http://jira.codehaus.org/browse/SONARDOTNT-291 -->
    <Exec Command="&quot;$(SonarRunnerPath)&quot; $(OptionalDebugArgument) -D sonar.projectKey=$(ProjectKey)-CS -D sonar.projectName=&quot;$(ProjectName)-CS&quot; -D sonar.projectVersion=$(BuildVersion) $(SonarConnectionParameters) -D sonar.exclusions=&quot;$(SonarGlobalCSharpExcludePattern)&quot; -D sonar.sources=&quot;$(SonarSource)&quot; -D project.home=&quot;$(SonarAbsoluteSolutionsToAnalyzeDirectory)&quot; -D sonar.projectBaseDir=&quot;$(SonarAbsoluteSolutionsToAnalyzeDirectory)&quot; -D sonar.language=cs -D sonar.dotnet.buildConfigurations=$(Configuration) -D sonar.dotnet.visualstudio.solution.file=&quot;%(SolutionsToAnalyze.Filename)%(SolutionsToAnalyze.Extension)&quot; -D csharp.sonar.projectBaseDir=%(SolutionsToAnalyze.RelativeDir) -D sonar.gallio.installDirectory=$(GallioPath) -D sonar.gallio.coverage.tool=OpenCover -D sonar.opencover.installDirectory=$(OpenCoverPath) -D sonar.dotnet.visualstudio.testProjectPattern=*$(UnitTestsProjectConventionName)*; -D sonar.gallio.coverage.excludes=&quot;$(ExcludeFromCoverage)&quot; -D sonar.fxcop.installDirectory=&quot;$(FxCopPath)&quot;" 
          Condition=" $(SkipAnalysis) == 'False'" IgnoreExitCode="true" />
    
  </Target>

  <!-- endregion Analyze targets -->

  <!-- beginregion Optimize targets -->

  <Target Name="OptimizeImages">	
    <!-- optimize all jpegs -->
    <ItemGroup>
      <AllJpegFiles Remove="@(AllJpegFiles)" />
      <AllJpegFiles Include="$(SourceDirectory)**\*.jpg" />
      <AllJpegFiles Include="$(SourceDirectory)**\*.jpeg" />
    </ItemGroup>
    <Exec Command="&quot;$(JpegtranPath)&quot; -progressive -optimize &quot;%(AllJpegFiles.FullPath)&quot; &quot;%(AllJpegFiles.FullPath)&quot;" Condition=" @(AllJpegFiles) != '' " />

    <!-- optimize all pngs -->
    <ItemGroup>
      <AllPngFiles Remove="@(AllPngFiles)" />
      <AllPngFiles Include="$(SourceDirectory)**\*.png" />
    </ItemGroup>
    <Exec Command="&quot;$(OptiPngPath)&quot; &quot;%(AllPngFiles.FullPath)&quot;" Condition=" @(AllPngFiles) != '' " />
  </Target>

  <!-- endregion Optimize targets -->

  <Target Name="UnicornSync">
    <Exec Command="&quot;$(WGetPath)&quot; $(UnicornSyncUrl) -O - --header=Authenticate:$(UnicornAuthToken)">
      <Output TaskParameter="ExitCode" PropertyName="ErrorCode"/>
    </Exec>
    <Message Importance="normal" Text="Unicorn sync exited with code $(ErrorCode)"/>
  </Target>

    <!-- beginregion Targets to use from outside -->	

  <Target Name="Build" DependsOnTargets="PrepareGlobalProperties;InstallBuildDependencies;Compile" />
  <Target Name="BuildAndRunUnitTests" DependsOnTargets="Build;RunUnitTests" />
  <Target Name="BuildAndRunIntegrationTests" DependsOnTargets="Build;RunIntegrationTests" />
  <Target Name="BuildAndRunAllTests" DependsOnTargets="Build;BeforeRunUnitTests;BeforeRunIntegrationTests;CoreRunTests" />	

  <Target Name="Minify" DependsOnTargets="PrepareGlobalProperties;MinifyJavaScript;MinifyCss" />

  <Target Name="Release" DependsOnTargets="PrepareGlobalProperties;InstallBuildDependencies;CompileCheck;CreateDirectories;BeforeRelease;Minify;ReleaseWebsites;ReleaseWebServices;ReleaseConsoleApps;ReleaseServices;ReleaseDatabases;ReleaseDatabasesViaTool;ReleaseWorkers;ReleaseStaticHtml;CoreRelease;ReleaseAzure;ReleaseNugetPackages;AfterRelease" />
  <Target Name="BuildAndRunUnitTestsAndRelease" DependsOnTargets="BeforeRelease;BuildAndRunUnitTests;Release" />

  <Target Name="Deploy" DependsOnTargets="PrepareGlobalProperties;InstallDeployDependencies;DeployWebsiteAndWebServiceAndStaticHtml;CoreMsDeployDeploy;DeployConsoleApp;DeployService;DeployDatabase;DeployAzure;DeployNugetPackages;AfterDeploy" />
  <Target Name="Delete" DependsOnTargets="PrepareGlobalProperties;DeleteAzure;DeleteDatabase;AfterDelete" />

  <!-- endregion Targets to use from outside -->	

  <!-- Only import specific file if it exists -->
  <Import Project="$(CustomBuildScriptsDirectory)targets-repository-specific.msbuild" Condition="exists('$(CustomBuildScriptsDirectory)targets-repository-specific.msbuild')"/>

</Project>